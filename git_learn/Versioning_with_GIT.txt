GIT Version Control 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

git command has

git help subcommand or git --help subcommand or git subcommand --help can display help on subcommand

  - Options 
1) $git --version
   git version 1.6.0

2) $git commit --amend     ## amend option specific to commit subcommand

  - Sub commands
These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   restore    Restore working tree files
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   diff       Show changes between commits, commit and working tree, etc
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   backfill   Download missing objects in a partial clone
   branch     List, create, or delete branches
   commit     Record changes to the repository
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   reset      Reset current HEAD to the specified state
   switch     Switch branches
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

  
Git commands understand both “short” and “long” options. For example, the git commit command treats the following examples as equivalents.  The short form, -m, uses a single hyphen, whereas the long form, --message, uses two.

$ git commit -m "Fixed a typo."
$ git commit --message="Fixed a typo."  

Finally, you can separate options from a list of arguments via the “bare double dash” convention. For instance, use the double dash to contrast the control portion of the command line from a list of operands, such as filenames.

$ git diff -w master origin -- tools/Makefile

You may need to use the double dash to separate and explicitly identify filenames if they might otherwise be mistaken for another part of the command. For example, if you happened to have both a file and a tag named main.c, then you will get different behavior:

# Checkout the tag named "main.c"
$ git checkout main.c

# Checkout the file named "main.c"
$ git checkout -- main.c

Creating an Initial Repository

$ mkdir local_web
$ cd local_web/
$ echo 'My website is alive!' > index.html

To turn ~/local_web or any directory into a Git repository, run git init

$ git init
Initialized empty Git repository in C:/Users/ADMIN/git_repo/local_web/.git/

Git doesn’t care whether you start with a completely empty directory or if you start with a directory full of files. In either case, the process of converting the directory into a Git repository is the same.
To signify that your directory is a Git repository, the git init command creates a hidden directory, called .git, at the top level of your project. Git places all its revision information in this one, top-level .git directory. Whereas CVS and SVN place revision information in CVS and .svn subdirectories within each of your project’s directories,

Adding a File to Your Repository

The command git init creates a new Git repository. Initially, each Git repository is empty. To manage content, you must explicitly deposit it in the repository. Such a conscious step separates scratch files from important files.

$ git add index.html    ## add index.html file to repository
$ git add .             ## Add all the files in the current directory to Git repository

After an add, Git knows that the file, index.html, is to remain in the repository. However, so far, Git has merely staged the file, an interim step before committal. Git separates the add and commit steps to avoid volatility. Imagine how disruptive, confusing, and time-consuming it would be to update the repository each time you add, remove, or change a file. Instead, multiple provisional and related steps, such as an add, can be “batched,” keeping the repository in a stable, consistent state.

$ echo "dummy file to be removed" > remove.html
$ git add remove.html

Running git status reveals this in-between state of all the added or removed files

$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   index.html
        new file:   remove.html

Remove the remove.html file 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git rm -f remove.html
rm 'remove.html'

again try the status command to see only the index.html in stage

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   index.html

In addition to actual changes to the directory and to file contents, Git records several other pieces of metadata with each commit, including a log message and the author of the change. A fully qualified git commit command supplies a log message and an author:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git commit -m "Initial contents of public_html" \   
> --author="Jon Loeliger <jdl@example.com>"
[master (root-commit) c58bec3] Initial contents of public_html
 Author: Jon Loeliger <jdl@example.com>
 1 file changed, 1 insertion(+)
 create mode 100644 index.html

after the commit is done check the status again git status indicates that there are no outstanding, staged changes to be committed

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master
nothing to commit, working tree clean

Configuring the Commit Author

Before making many commits to a repository, you should establish some basic environment and configuration options. At a bare minimum, Git must know your name and email address. You may specify your identity on every commit command line, as shown previously, but that is the hard way and quickly becomes tedious.
 
ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git config user.name "Sivanesan G"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git config user.email "nesan.committer@gmail.com"

You can also tell Git your name and email address using the GIT_AUTHOR_NAME and GIT_AUTHOR_EMAIL environment variables. If set, these variables override all configuration settings.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ export GIT_AUTHOR_NAME="Sivanesan G"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ export GIT_AUTHOR_EMAIL="nesan.committer@gmail.com"

check with env command and ensure the env variables are set properly 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ env | grep GIT_
GIT_AUTHOR_EMAIL=nesan.committer@gmail.com
GIT_AUTHOR_NAME=Sivanesan G

Making Another Commit

Let’s commit an alteration to the index.html file. Open the file, convert it to HTML, and save the file.
then try to commeit 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git commit .
Aborting commit due to empty commit message.

If you are already somewhat familiar with Git, you may be tempted to think “Aha! You need to git add index.html before you can commit that file!” But that isn’t true. Because the file was already added to the repository (in “Adding a File to Your Repository” on page 22), there’s no need to tell the index about the file; it already knows. Furthermore, file changes are captured when directly committing a file named on the command line! Using a generic git commit without naming the file would not have worked in this case.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git commit index.html
[master 4e35d12] convert to proper HTML
 1 file changed, 5 insertions(+), 1 deletion(-)

Viewing Your Commits

Some Git commands show the sequence of individual commits, others show the summary of an individual commit, and still others show the full details of any commit in the repository. The command git log yields a sequential history of the individual commits within the repository

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git log
commit 4e35d12e95c39f7fd490f649de9f15d703217488 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 13:46:10 2025 +0530

    convert to proper HTML

commit c58bec389bf514d7c920823c748180a827b19d3b
Author: Jon Loeliger <jdl@example.com>
Date:   Thu Nov 27 13:19:30 2025 +0530

    Initial contents of public_html
 
To see more detail about a particular commit, use git show with a commit number: 
If you run git show without an explicit commit number, it simply shows the details of the most recent commit.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show c58bec389bf514d7c920823c748180a827b19d3b
commit c58bec389bf514d7c920823c748180a827b19d3b
Author: Jon Loeliger <jdl@example.com>
Date:   Thu Nov 27 13:19:30 2025 +0530

    Initial contents of public_html

diff --git a/index.html b/index.html
new file mode 100644
index 0000000..34217e9
--- /dev/null
+++ b/index.html
@@ -0,0 +1 @@
+My website is alive!

this is details for secomd commit 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show 4e35d12e95c39f7fd490f649de9f15d703217488
commit 4e35d12e95c39f7fd490f649de9f15d703217488 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 13:46:10 2025 +0530

    convert to proper HTML

diff --git a/index.html b/index.html
index 34217e9..cfae612 100644
--- a/index.html
+++ b/index.html
@@ -1 +1,5 @@
-My website is alive!
+<html>
+<body>
+My web site is alive!
+</body>
+</html>

Another view, show-branch, provides concise, one-line summaries for the current development branch:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show-branch
[master] convert to proper HTML

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show-branch --more=10
[master] convert to proper HTML
[master^] Initial contents of public_html

The name master is the default branch name. The phrase --more=10 reveals up to an additional 10 more versions,

Viewing Commit Differences



Edit and commit again adding new line for V3

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git commit index.html
[master 10e7fc3] just added a new line for V3
 1 file changed, 1 insertion(+)

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master
nothing to commit, working tree clean

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show-branch --more=10
[master] just added a new line for V3
[master^] convert to proper HTML
[master~2] Initial contents of public_html

check git log 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git log
commit 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 15:00:53 2025 +0530

    just added a new line for V3

commit 4e35d12e95c39f7fd490f649de9f15d703217488
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 13:46:10 2025 +0530

    convert to proper HTML

commit c58bec389bf514d7c920823c748180a827b19d3b
Author: Jon Loeliger <jdl@example.com>
Date:   Thu Nov 27 13:19:30 2025 +0530

    Initial contents of public_html

To see the differences between the two revisions of index.html, recall both full commit ID names and run git diff

Check difference between Latest and the previous (second) version

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git diff 4e35d12e95c39f7fd490f649de9f15d703217488 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d
diff --git a/index.html b/index.html
index cfae612..e6fd42d 100644
--- a/index.html
+++ b/index.html
@@ -1,5 +1,6 @@
 <html>
 <body>
 My web site is alive!
+this is version 3
 </body>
 </html>

Difference between initial and the Latest versions

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git diff c58bec389bf514d7c920823c748180a827b19d3b 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d
diff --git a/index.html b/index.html
index 34217e9..e6fd42d 100644
--- a/index.html
+++ b/index.html
@@ -1 +1,6 @@
-My website is alive!
+<html>
+<body>
+My web site is alive!
+this is version 3
+</body>
+</html>


difference between initial and the pervious (second) version

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git diff c58bec389bf514d7c920823c748180a827b19d3b 4e35d12e95c39f7fd490f649de9f15d703217488
diff --git a/index.html b/index.html
index 34217e9..cfae612 100644
--- a/index.html
+++ b/index.html
@@ -1 +1,5 @@
-My website is alive!
+<html>
+<body>
+My web site is alive!
+</body>
+</html>

Removing and Renaming Files in Your Repository

create a new file in folder 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ echo "remove file test" > remove_v1.txt

check the new file is in folder 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ ls
index.html  remove_v1.txt

try to remove it - gives error as the file is not added yet in repository

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git rm remove_v1.txt
fatal: pathspec 'remove_v1.txt' did not match any files

Add it to repo then try to remove 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git add remove_v1.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git rm remove_v1.txt
error: the following file has changes staged in the index:
    remove_v1.txt
(use --cached to keep the file, or -f to force removal)

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git rm -f remove_v1.txt
rm 'remove_v1.txt'

check if the file is removed from the folder also, yes remove.txt is removed from the workspace

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ ls
index.html

you can rename a file with git mv command 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ echo "foo file" > foo.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        foo.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git add foo.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git mv foo.html bar.html

when the file name is changed in the repository the local file name also is changed

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   bar.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ ls
bar.html  index.html

try direct mv command to rename file 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ mv bar.html foo_v1.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ ls
foo_v1.html  index.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   bar.html

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        deleted:    bar.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        foo_v1.html

try to commit and see if the foo_v1.html is also commited and its in which name now

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git commit -m "try indirect rename with mv command"
[master 44711ce] try indirect rename with mv command
 1 file changed, 1 insertion(+)
 create mode 100644 bar.html

check the branch changes 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show-branch --more=10
[master] try indirect rename with mv command
[master^] just added a new line for V3
[master~2] convert to proper HTML
[master~3] Initial contents of public_html

check git log then try to check the difference

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git log
commit 44711ceffa7c31391948e7c61ddf6f0b1f853e73 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 15:26:15 2025 +0530

    try indirect rename with mv command

commit 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 15:00:53 2025 +0530

    just added a new line for V3

commit 4e35d12e95c39f7fd490f649de9f15d703217488
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 13:46:10 2025 +0530

    convert to proper HTML

commit c58bec389bf514d7c920823c748180a827b19d3b
Author: Jon Loeliger <jdl@example.com>
Date:   Thu Nov 27 13:19:30 2025 +0530

    Initial contents of public_html

check git diff to understand what happened to bar.html which is no named as foo_v1.txt 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git diff 44711ceffa7c31391948e7c61ddf6f0b1f853e73 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d
diff --git a/bar.html b/bar.html
deleted file mode 100644
index 3f9a7b1..0000000
--- a/bar.html
+++ /dev/null
@@ -1 +0,0 @@
-foo file

in the repo its still in the name bar.html so indirect mv command is not working for that we need to use it as below

$ mv bar.html foo_v1.html
$ git rm bar.html
$ git add foo_v1.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ ls
foo_v1.html  index.html

frist restore local foo_v1.html to bar.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ mv foo_v1.html bar.html

Then try to rename bar.html in the repo to name foo_v1.html 

$ mv bar.html foo_v1.html
$ git rm bar.html
$ git add foo_v1.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ mv bar.html foo_v1.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git rm bar.html
rm 'bar.html'

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git add foo_v1.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        renamed:    bar.html -> foo_v1.html
		
only in the next commit the name will change 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git commit -m "indirect rename success"
[master 33cbe08] indirect rename success
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename bar.html => foo_v1.html (100%)

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show-branch --more=10
[master] indirect rename success
[master^] try indirect rename with mv command
[master~2] just added a new line for V3
[master~3] convert to proper HTML
[master~4] Initial contents of public_html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git log
commit 33cbe083137c5580054b7df359317d85f00b71a5 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 15:36:29 2025 +0530

    indirect rename success

commit 44711ceffa7c31391948e7c61ddf6f0b1f853e73
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 15:26:15 2025 +0530

    try indirect rename with mv command

commit 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 15:00:53 2025 +0530

    just added a new line for V3

commit 4e35d12e95c39f7fd490f649de9f15d703217488
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Nov 27 13:46:10 2025 +0530

    convert to proper HTML

commit c58bec389bf514d7c920823c748180a827b19d3b
Author: Jon Loeliger <jdl@example.com>
Date:   Thu Nov 27 13:19:30 2025 +0530

    Initial contents of public_html

check git diff beween last two versions to see the rename 
	
ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git diff 33cbe083137c5580054b7df359317d85f00b71a5 44711ceffa7c31391948e7c61ddf6f0b1f853e73
diff --git a/foo_v1.html b/bar.html
similarity index 100%
rename from foo_v1.html
rename to bar.html

Making a Copy of Your Repository

For the purposes of this tutorial, let’s just make a copy in your working directory local_web and call it local_web_clone:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ cd ..

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ git clone local_web local_web_clone
Cloning into 'local_web_clone'...
done.

Although these two Git repositories now contain exactly the same objects, files, and directories, there are some subtle differences. You may want to explore those differences with commands such as:
		
ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ ls -lsa local_web local_web_clone
local_web:
total 10
4 drwxr-xr-x 1 ADMIN 197121  0 Nov 27 15:34 ./
0 drwxr-xr-x 1 ADMIN 197121  0 Nov 27 15:47 ../
4 drwxr-xr-x 1 ADMIN 197121  0 Nov 27 15:36 .git/
1 -rw-r--r-- 1 ADMIN 197121  9 Nov 27 15:21 foo_v1.html
1 -rw-r--r-- 1 ADMIN 197121 70 Nov 27 15:00 index.html

local_web_clone:
total 10
4 drwxr-xr-x 1 ADMIN 197121  0 Nov 27 15:47 ./
0 drwxr-xr-x 1 ADMIN 197121  0 Nov 27 15:47 ../
4 drwxr-xr-x 1 ADMIN 197121  0 Nov 27 15:47 .git/
1 -rw-r--r-- 1 ADMIN 197121  9 Nov 27 15:47 foo_v1.html
1 -rw-r--r-- 1 ADMIN 197121 70 Nov 27 15:47 index.html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ diff -r local_web local_web_clone
Only in local_web/.git: COMMIT_EDITMSG
diff -r local_web/.git/config local_web_clone/.git/config
8,10c8,13
< [user]
<       name = Sivanesan G
<       email = nesan.committer@gmail.com
---
> [remote "origin"]
>       url = C:/Users/ADMIN/git_repo/local_web
>       fetch = +refs/heads/*:refs/remotes/origin/*
> [branch "master"]
>       remote = origin
>       merge = refs/heads/master
Binary files local_web/.git/index and local_web_clone/.git/index differ
diff -r local_web/.git/logs/HEAD local_web_clone/.git/logs/HEAD
1,5c1
< 0000000000000000000000000000000000000000 c58bec389bf514d7c920823c748180a827b19d3b Nesan <nesan.committer@gmail.com> 1764229770 +0530  commit (initial): Initial contents of public_html
< c58bec389bf514d7c920823c748180a827b19d3b 4e35d12e95c39f7fd490f649de9f15d703217488 Sivanesan G <nesan.committer@gmail.com> 1764231370 +0530    commit: convert to proper HTML
< 4e35d12e95c39f7fd490f649de9f15d703217488 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d Sivanesan G <nesan.committer@gmail.com> 1764235853 +0530    commit: just added a new line for V3
< 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d 44711ceffa7c31391948e7c61ddf6f0b1f853e73 Sivanesan G <nesan.committer@gmail.com> 1764237375 +0530    commit: try indirect rename with mv command
< 44711ceffa7c31391948e7c61ddf6f0b1f853e73 33cbe083137c5580054b7df359317d85f00b71a5 Sivanesan G <nesan.committer@gmail.com> 1764237989 +0530    commit: indirect rename success
---
> 0000000000000000000000000000000000000000 33cbe083137c5580054b7df359317d85f00b71a5 Nesan <nesan.committer@gmail.com> 1764238671 +0530  clone: from C:/Users/ADMIN/git_repo/local_web
diff -r local_web/.git/logs/refs/heads/master local_web_clone/.git/logs/refs/heads/master
1,5c1
< 0000000000000000000000000000000000000000 c58bec389bf514d7c920823c748180a827b19d3b Nesan <nesan.committer@gmail.com> 1764229770 +0530  commit (initial): Initial contents of public_html
< c58bec389bf514d7c920823c748180a827b19d3b 4e35d12e95c39f7fd490f649de9f15d703217488 Sivanesan G <nesan.committer@gmail.com> 1764231370 +0530    commit: convert to proper HTML
< 4e35d12e95c39f7fd490f649de9f15d703217488 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d Sivanesan G <nesan.committer@gmail.com> 1764235853 +0530    commit: just added a new line for V3
< 10e7fc3fb69a639e45e8cca23334d7d83a3fc49d 44711ceffa7c31391948e7c61ddf6f0b1f853e73 Sivanesan G <nesan.committer@gmail.com> 1764237375 +0530    commit: try indirect rename with mv command
< 44711ceffa7c31391948e7c61ddf6f0b1f853e73 33cbe083137c5580054b7df359317d85f00b71a5 Sivanesan G <nesan.committer@gmail.com> 1764237989 +0530    commit: indirect rename success
---
> 0000000000000000000000000000000000000000 33cbe083137c5580054b7df359317d85f00b71a5 Nesan <nesan.committer@gmail.com> 1764238671 +0530  clone: from C:/Users/ADMIN/git_repo/local_web
Only in local_web_clone/.git/logs/refs: remotes
Only in local_web_clone/.git: packed-refs
Only in local_web_clone/.git/refs: remotes

On a local filesystem like this, using git clone to make a copy of a repository is quite similar to cp -a or rsync. However, Git supports a richer set of repository sources, including network names, for naming the repository to be cloned.

Once you clone a repository, you are able to modify the cloned version, make new commits, inspect its logs and history, and so on. It is a complete repository with full history.

Configuration Files

Git’s configuration files are all simple text files in the style of .ini files. They record various choices and settings used by many Git commands. Some settings represent surely personal preferences (should a color.pager be used?); others are vital to a repository functioning correctly (core.repositoryformatversion); and still others tweak command behavior a bit (gc.auto).

Like many tools, Git supports a hierarchy of configuration files. In decreasing precedence they are:

.git/config
 Repository-specific configuration settings manipulated with the --file option or by default. These settings have the highest precedence.

~/.gitconfig
 User-specific configuration settings manipulated with the --global option.

/etc/gitconfig
 System-wide configuration settings manipulated with the --system option if you have proper Unix file write permissions on it. These settings have the lowest precedence. Depending on your actual installation, the system settings file might be somewhere else (perhaps in /usr/local/etc/gitconfig), or may be entirely absent.

For example, to establish an author name and email address that will be used on all the commits you make for all of your repositories, configure values for user.name and user.email in your $HOME/.gitconfig file using git config --global. [--global → Applies to YOUR USER ACCOUNT + ALL] REPOSITORIES

git config --global user.name "Sivanesan G"
git config --global user.email "nesan.committer@gmail.com"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~
$ cat .gitconfig
[filter "lfs"]
        clean = git-lfs clean -- %f
        smudge = git-lfs smudge -- %f
        process = git-lfs filter-process
        required = true
[user]
        name = Sivanesan G
        email = nesan.committer@gmail.com
		
Or, to set a repository-specific name and email address that would override a --global setting, simply omit the --global flag: you must be in repo folder to use this commands

## Git Config Hierarchy (Precedence Order)
1. LOCAL (--local or repo .git/config) → Current repo ONLY
2. GLOBAL (--global) 	               → Your user + ALL your repos  
3. SYSTEM (--system)                   → All users/system-wide

git config user.email "local@repo.com"    → THIS repo only
git config --global user.email "you@global.com" → ALL your repos
git config --system user.email "admin@org.com" → All users (rare)

## check all the different scope settings 
ADMIN@DESKTOP-O8I6CUH MINGW64 ~
$ git config --list --show-origin
file:C:/Program Files/Git/etc/gitconfig diff.astextplain.textconv=astextplain
file:C:/Program Files/Git/etc/gitconfig filter.lfs.clean=git-lfs clean -- %f
file:C:/Program Files/Git/etc/gitconfig filter.lfs.smudge=git-lfs smudge -- %f
file:C:/Program Files/Git/etc/gitconfig filter.lfs.process=git-lfs filter-process
file:C:/Program Files/Git/etc/gitconfig filter.lfs.required=true
file:C:/Program Files/Git/etc/gitconfig http.sslbackend=openssl
file:C:/Program Files/Git/etc/gitconfig http.sslcainfo=C:/Program Files/Git/mingw64/etc/ssl/certs/ca-bundle.crt
file:C:/Program Files/Git/etc/gitconfig core.autocrlf=false
file:C:/Program Files/Git/etc/gitconfig core.fscache=true
file:C:/Program Files/Git/etc/gitconfig core.symlinks=false
file:C:/Program Files/Git/etc/gitconfig core.editor="C:\\Program Files\\Notepad++\\notepad++.exe" -multiInst -notabbar -nosession -noPlugin
file:C:/Program Files/Git/etc/gitconfig pull.rebase=false
file:C:/Program Files/Git/etc/gitconfig credential.helper=manager
file:C:/Program Files/Git/etc/gitconfig credential.https://dev.azure.com.usehttppath=true
file:C:/Program Files/Git/etc/gitconfig init.defaultbranch=master
file:C:/Users/ADMIN/.gitconfig  filter.lfs.clean=git-lfs clean -- %f
file:C:/Users/ADMIN/.gitconfig  filter.lfs.smudge=git-lfs smudge -- %f
file:C:/Users/ADMIN/.gitconfig  filter.lfs.process=git-lfs filter-process
file:C:/Users/ADMIN/.gitconfig  filter.lfs.required=true
file:C:/Users/ADMIN/.gitconfig  user.name=Sivanesan G
file:C:/Users/ADMIN/.gitconfig  user.email=nesan.committer@gmail.com
file:C:/Users/ADMIN/.gitconfig  alias.show-graph=log --graph --abbrev-commit --pretty=oneline
file:C:/Users/ADMIN/.gitconfig  http.sslbackend=schannel
file:C:/Users/ADMIN/.gitconfig  http.sslverify=true

# Your global only configurations 
ADMIN@DESKTOP-O8I6CUH MINGW64 ~
$ git config --global --list
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
filter.lfs.process=git-lfs filter-process
filter.lfs.required=true
user.name=Sivanesan G
user.email=nesan.committer@gmail.com
alias.show-graph=log --graph --abbrev-commit --pretty=oneline
http.sslbackend=schannel
http.sslverify=true

# Current repo only
ADMIN@DESKTOP-O8I6CUH MINGW64 ~
$ git config --local --list
fatal: --local can only be used inside a git repository

ADMIN@DESKTOP-O8I6CUH MINGW64 ~
$ cd git_repo/local_web

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git config user.name "Sivanesan G for bots"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git config user.email "nesan.committer@gmail.com"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ cd .git/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web/.git (GIT_DIR!)
$ cat config
[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
[user]
        name = Sivanesan G for bots
        email = nesan.committer@gmail.com
		
Use git config -l to list the settings of all the variables collectively found in the complete set of configuration files:		

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web/.git (GIT_DIR!)
$ git config -l
diff.astextplain.textconv=astextplain
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
filter.lfs.process=git-lfs filter-process
filter.lfs.required=true
http.sslbackend=openssl
http.sslcainfo=C:/Program Files/Git/mingw64/etc/ssl/certs/ca-bundle.crt
core.autocrlf=false
core.fscache=true
core.symlinks=false
core.editor="C:\\Program Files\\Notepad++\\notepad++.exe" -multiInst -notabbar -nosession -noPlugin
pull.rebase=false
credential.helper=manager
credential.https://dev.azure.com.usehttppath=true
init.defaultbranch=master
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
filter.lfs.process=git-lfs filter-process
filter.lfs.required=true
user.name=Sivanesan G
user.email=nesan.committer@gmail.com
core.repositoryformatversion=0
core.filemode=false
core.bare=false
core.logallrefupdates=true
core.symlinks=false
core.ignorecase=true
user.name=Sivanesan G for bots
user.email=nesan.committer@gmail.com

Make a new repository test_config

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ mkdir test_config

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ cd test_config/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/test_config
$ git init
Initialized empty Git repository in C:/Users/ADMIN/git_repo/test_config/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/test_config (master)
$ git config --global user.name "Sivanesan G"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/test_config (master)
$ git config --global user.email "nesan.committer@gmail.com"

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/test_config (master)
$ git config user.name "nesan at test_config"

use config list command

$ git config -l
diff.astextplain.textconv=astextplain
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
user.name=Sivanesan G
user.email=nesan.committer@gmail.com
core.repositoryformatversion=0
core.filemode=false
core.bare=false
core.logallrefupdates=true
core.symlinks=false
core.ignorecase=true
user.name=nesan at test_config

you can check contents for config file with cat command also

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/test_config (master)
$ cat .git/config
[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
[user]
        name = nesan at test_config
		
Use the --unset option to remove a setting:
$ git config --unset --global user.email

Multiple configuration options and environment variables frequently exist for the same
purpose. For example, the editor to be used when composing a commit log message
follows these steps, in order:
• GIT_EDITOR environment variable
• core.editor configuration option
• VISUAL environment variable
• EDITOR environment variable
• the vi command

Configuring an Alias

If there is a common but complex Git command that you type frequently, consider setting up a simple Git alias for it.

$ git config --global alias.show-graph 'log --graph --abbrev-commit --pretty=oneline'

$ cd ../local_web

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git show-graph
* 33cbe08 (HEAD -> master) indirect rename success
* 44711ce try indirect rename with mv command
* 10e7fc3 just added a new line for V3
* 4e35d12 convert to proper HTML
* c58bec3 Initial contents of public_html

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/local_web (master)
$ git log --graph --abbrev-commit --pretty=oneline
* 33cbe08 (HEAD -> master) indirect rename success
* 44711ce try indirect rename with mv command
* 10e7fc3 just added a new line for V3
* 4e35d12 convert to proper HTML
* c58bec3 Initial contents of public_html

GIT terminologies
~~~~~~~~~~~~~~~~~~

Repositories : A Git repository is simply a database containing all the information needed to retain and manage the revisions and history of a project. In Git, as with most version control systems, a repository retains a complete copy of the entire project throughout its lifetime. However, unlike most other VCSs, the Git repository not only provides a complete working copy of all the files in the repository, but also a copy of the repository itself with which to work.

Unlike file data and other repository metadata, configuration settings are not propagated from one repository to another during a clone, or duplicating, operation.

Within a repository, Git maintains two primary data structures, the object store and the index. All of this repository data is stored at the root of your working directory in a hidden subdirectory named .git. 

The object store is designed to be efficiently copied during a clone operation, The index is transitory information, is private to a repository, and can be created or modified on demand as needed.

Git Object Types

At the heart of Git’s repository implementation is the object store. It contains your original data files and all the log messages, author information, dates, and other information required to rebuild any version or branch of the project.

Git places only four types of objects in the object store: the blobs, trees, commits, and tags. These four atomic objects form the foundation of Git’s higher level data structures.

Blobs : Each version of a file is represented as a blob, A blob holds a file’s data but does not contain any metadata about the file or even its name
Trees : A tree object represents one level of directory information. It records blob identifiers, path names, and a bit of metadata for all the files in one directory. It can also recursively reference other (sub)tree objects and thus build a complete hierarchy of files and subdirectories.
Commits : A commit object holds metadata for each change introduced into the repository, including the author, committer, commit date, and log message. Each commit
points to a tree object that captures, in one complete snapshot, the state of the repository at the time the commit was performed. The initial commit, or root commit, has no parent
Tags : A tag object assigns an arbitrary yet presumably human readable name to a specific object, usually a commit.

Over time, all the information in the object store changes and grows, tracking and modeling your project edits, additions, and deletions. To use disk space and network bandwidth efficiently, Git compresses and stores the objects in pack files, which are also placed in the object store.

Index : The index is a temporary and dynamic binary file that describes the directory structure of the entire repository. More specifically, the index captures a version of the project’s overall structure at some moment in time. As the developer, you execute Git commands to stage changes in the index. Changes usually add, delete, or edit some file or set of files. The index records and retains those changes, keeping them safe until you are ready to commit them. Thus, the index allows a gradual transition, usually guided by you, from one complex repository state to another, presumably better state.

Content-Addressable Names : The Git object store is organized and implemented as a content-addressable storage system. Specifically, each object in the object store has a unique name produced by applying SHA1 to the contents of the object, yielding an SHA1 hash value. Because the complete contents of an object contribute to the hash value and the hash value is believed to be effectively unique to that particular content, the SHA1 hash is a sufficient index or name for that object in the object database.
SHA1 values are 160-bit values that are usually represented as a 40-digit hexadecimal number, such as 9da581d910c9c4ac93557ca4859e767f5caf5169 this is also called as object ID. Sometimes, during display, SHA1 values are abbreviated to a smaller, unique prefix. 

First, Git’s object store is based on the hashed computation of the contents of its objects, not on the file or directory names from the user’s original file layout. Thus, when Git places a file into the object store, it does so based on the hash of the data and not on the name of the file. If two separate files have exactly the same content, whether in the same or different directories, Git stores a single copy of that content as a blob within the object store. Both files in the project, regardless of where they are located in the user’s directory structure, use that same object for content. If one of those files changes, Git computes a new SHA1 for it, determines that it is now a different blob object, and adds the new blob to the object store. The original blob remains in the object store for the unchanged file to use.

Second, Git’s internal database efficiently stores every version of every file—not their differences—as files go from one revision to the next. Because Git uses the hash of a file’s complete content as the name for that file, it must operate on each complete copy of the file. It cannot base its work or its object store entries on only part of the file’s content nor on the differences between two revisions of that file.

Pathname Versus Content
As with many other VCSs, Git needs to maintain an explicit list of files that form the content of the repository. However, this need not require that Git’s manifest be based on file names. Indeed, Git treats the name of a file as a piece of data that is distinct from the contents of that file. In this way, it separates index from data in the traditional database sense. Git merely records each pathname and makes sure it can accurately reproduce the files and directories from its content, which is indexed by a hash value.

Pack Files : Git uses a more efficient storage mechanism called a pack file. To create a packed file, Git first locates files whose content is very similar and stores the complete content for one of them. It then computes the differences, or deltas, between similar files and stores just the differences. For example, if you were to just change or add one line to a file, Git might store the complete, newer version and then take note of the one line change as a delta and store that in the pack too.
Thus, Git has a fairly elaborate algorithm to locate and match up potential delta candidates globally within a repository. Furthermore, Git is able to construct a series of deltas from one version of a file to a second, to a third, etc. Git also maintains the knowledge of the original blob SHA1 for each complete file (either the complete content or as a reconstruction after deltas are applied) within the packed representation. This provides the basis for an index mechanism to locate objects within a pack.
Packed files are stored in the object store alongside the other objects. They are also used for efficient data transfer of repositories across a network.

The blob object is at the “bottom” of the data structure; it references nothing and is referenced only by tree objects. Tree objects point to blobs and possibly to other trees as well. Any given tree object might be pointed at by many different commit objects. A commit points to one particular tree that is introduced into the repository by the commit. Each tag can point to, at most, one commit. The branch is not a fundamental Git object, yet it plays a crucial role in naming commits.

in every branch there will be tag ID (tag name) which is pointing to commit ID which is pointing to tree ID which will inturn point to one or more object IDs which are commited in particular commit. There can be mulltiple commits within one branch for each commit above IDs are created and they are all unique ids which is maintained by GIT. When ever a new commit happens the new commit (child commit) points to be previous commit (parent commit) and inturn each commit contains tree which points to all the objects (unchanged objects in old commit will be pointed from the old tree itself and any new objects will be part of new tree belogning to current commit.

Git Concepts at Work

Let’s create a new repository and inspect the internal files and object store in much greater detail. 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ mkdir checkGitFolder

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ cd checkGitFolder/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder
$ git init
Initialized empty Git repository in C:/Users/ADMIN/git_repo/checkGitFolder/.git/

List all the files in the current folder which is empty repository with no files added but the .git folder has all the stucture in place to manage the repo

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ find .
.
./.git
./.git/config
./.git/description
./.git/HEAD
./.git/hooks
./.git/hooks/applypatch-msg.sample
./.git/hooks/commit-msg.sample
./.git/hooks/fsmonitor-watchman.sample
./.git/hooks/post-update.sample
./.git/hooks/pre-applypatch.sample
./.git/hooks/pre-commit.sample
./.git/hooks/pre-merge-commit.sample
./.git/hooks/pre-push.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/pre-receive.sample
./.git/hooks/prepare-commit-msg.sample
./.git/hooks/push-to-checkout.sample
./.git/hooks/sendemail-validate.sample
./.git/hooks/update.sample
./.git/info
./.git/info/exclude
./.git/objects
./.git/objects/info
./.git/objects/pack
./.git/refs
./.git/refs/heads
./.git/refs/tags

In general, you don’t have to view or manipulate the files in .git. These “hidden” files are considered part of Git’s plumbing or configuration. Git has a small set of plumbing commands to manipulate these hidden files, but you will rarely use them. Initially, the .git/objects directory (the directory for all of Git’s objects) is empty,

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ find .git/objects/
.git/objects/
.git/objects/info
.git/objects/pack

create a simple file now 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ echo "hello world" > hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git add hello.txt

Check the files in objects folder again there is a folder 3b created and in that there is file 18e512dba79e4c8300dd08aeb37f8e728b8dad created. 
When it creates an object for hello.txt, Git doesn’t care that the filename is hello.txt. Git cares only about what’s inside the file: the sequence of 12 bytes that represent “hello world” and the terminating newline (the same blob created earlier). Git performs a few operations on this blob, calculates its SHA1 hash, and enters it into the object store as a file named after the hexadecimal representation of the hash.

The 160 bits of an SHA1 hash correspond to 20 bytes, which takes 40 bytes of hexadecimal to display, so the content is stored as .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad. Git inserts a / after the first two digits to improve filesystem efficiency. basically it creates subdirectories with first two bytes and places all files starting with that hash key in that subfolder so large number of files can be handled easily.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ find .git/objects/
.git/objects/
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/info
.git/objects/pack

check the contents of both the files

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
hello world

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ cat hello.txt
hello world

Git also knows that 40 characters is a bit chancy to type by hand, so it provides a command to look up objects by a unique prefix of the object hash using the rev-parse command as below:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git rev-parse 3b18e512d
3b18e512dba79e4c8300dd08aeb37f8e728b8dad

in this the 3b18e512dba79e4c8300dd08aeb37f8e728b8dad is SHA1 hash of the contents of the hello.txt check that with command  

As mentioned before, Git tracks the pathnames of files through another kind of object called a tree. When you use git add, Git creates an object for the contents of each file you add, but it doesn’t create an object for your tree right away. Instead, it updates the index. The index is found in .git/index and keeps track of file pathnames and corresponding blobs. Each time you run commands such as git add, git rm, or git mv, Git updates the index with the new pathname and blob information.

Whenever you want, you can create a tree object from your current index by capturing a snapshot of its current information with the low-level git write-tree command. 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git ls-files -s
100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0       hello.txt

Next, let’s capture the index state and save it to a tree object:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60

you can see the tree is created as we requested that to be written for our use the tree object, at 68aba6 in 68 subfolder.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ find .git/objects
.git/objects
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/68
.git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60
.git/objects/info
.git/objects/pack

But what does a tree look like? Because it’s an object, just like the blob, you can use the same low-level command to view it.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p 68aba6
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt

The contents of the object should be easy to interpret. The first number, 100644, represents the file attributes of the object in octal, which should be familiar to anyone who has used the Unix chmod command. Here, 3b18e5 is the object name of the hello world blob, and hello.txt is the name associated with that blob.

Every time you compute another tree object for the same index, the SHA1 hash remains exactly the same. Git doesn’t need to recreate a new tree object

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git write-tree
68aba62e560c0ebc3396e8ae9335232cd93a3f60

Bob might have created the tree by combining commits A and B from Jennie and commit C from Sergey, whereas you got commit A from Sue and an update from Lakshmi that combines commits B and C. The results are the same, and this facilitates distributed development. So when the sha1 hash is always same for the same set of blob objects and trees with same objects.

The converse is also true: If you don’t find an object with a specific hash in your object store, then you can be confident that you do not hold a copy of that exact object. In sum, you can determine whether your object store does or does not have a particular object even though you know nothing about its (potentially very large) contents. The hash thus serves as a reliable label or name for the object.

Tree Hierarchies : 
It’s nice to have information regarding a single file, as was shown in the previous section, but projects contain complex, deeply nested directories that are refactored and moved around over time. Let’s see how Git handles this by creating a new subdirectory that contains an identical copy of the hello.txt file:

create a copy of hello.txt in a new folder named subdir and then run the write-tree command

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ pwd
/c/Users/ADMIN/git_repo/checkGitFolder

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ mkdir subdir

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ cp hello.txt ./subdir/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git add ./subdir/hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git write-tree
492413269336d21fac079d4a4672e55d5d2147ac

check the content of the new tree object 492132

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p 49241
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt
040000 tree 68aba62e560c0ebc3396e8ae9335232cd93a3f60    subdir

The new top-level tree contains two items: the original hello.txt file as well as the new subdir directory, which is of type tree instead of blob. Also SURPRISING is Look closer at the object name of subdir. It’s your old friend, 68aba62e560c0ebc3396e8ae9335232cd93a3f60 which is same the object name of tree we created for parent directory with hello.txt file. What just happened? The new tree for subdir contains only one file, hello.txt, and that file contains the same old “hello world” content. So the subdir tree is exactly the same as the older, top-level tree! And of course it has the same SHA1 object name as before.

check the contents of the new tree 68aba62 which is the subdir tree

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p 68aba6
100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    hello.txt

SURPRISE is it has pointer to the original blob hello.txt in the parent folder itself because both files have the same contents 

check the contents of objects folder 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ find .git/objects/
.git/objects/
.git/objects/3b
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/49
.git/objects/49/2413269336d21fac079d4a4672e55d5d2147ac
.git/objects/68
.git/objects/68/aba62e560c0ebc3396e8ae9335232cd93a3f60
.git/objects/info
.git/objects/pack

There are still only three unique objects: a blob containing “hello world”; a tree containing hello.txt, which contains the text “hello world” plus a new line; and a second tree that contains another reference to hello.txt along with the first tree.

Commits

The next object to discuss is the commit. Now that hello.txt has been added with git add and the tree object has been produced with git write-tree, you can create a commit object using low-level commands like this:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ echo -n "Commit a file that says hello\n" | git commit-tree 492413269336d21fac079d4a4672e55d5d2147ac
c4e97ac5714bdbab7b93cc04efcb22ae2ca36a70

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p c4e97ac57
tree 492413269336d21fac079d4a4672e55d5d2147ac
author Sivanesan G <nesan.committer@gmail.com> 1764341220 +0530
committer Sivanesan G <nesan.committer@gmail.com> 1764341220 +0530

Commit a file that says hello\n

try to commit again, then new commit object is created with new commit ID but the contents are same, both commits point to the same tree 492413269336d21fac079d4a4672e55d5d2147ac 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ echo -n "Commit a file that says hello\n" \
> | git commit-tree 492413269336d21fac079d4a4672e55d5d2147ac
7af3c02564043816e0e4a2866ece6e2f0810f160

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p 7af3c02564043816e0e4a2866ece6e2f0810f160
tree 492413269336d21fac079d4a4672e55d5d2147ac
author Sivanesan G <nesan.committer@gmail.com> 1764341035 +0530
committer Sivanesan G <nesan.committer@gmail.com> 1764341035 +0530

Commit a file that says hello\n

Commit object contains below 4 items
1) The name of a tree object that actually identifies the associated files
2) The name of the person who composed the new version (the author) and the time when it was composed
3) The name of the person who placed the new version into the repository (the committer) and the time when it was committed
4) A description of the reason for this revision (the commit message)

why the commit ID is different for two commits though we commit the same content hello.txt?? that is because the contents of these commit object has different content though the author is same the time of commit for each commit is different so git generated two different commit ID for each commit.

In real life, you can (and should!) pass over the low-level git write-tree and git commit-tree steps, and just use the git commit command. You don’t need to remember all those plumbing commands to be a perfectly happy Git user.

Commit objects are also stored in a graph structure, although it’s completely different from the structures used by tree objects. When you make a new commit, you can give it one or more parent commits. By following back through the chain of parents, you can discover the history of your project.

Tags : Tag is basically used to name any commit that you do.

Finally, the last object Git manages is the tag. Although Git implements only one kind of tag object, there are two basic tag types, usually called lightweight and annotated.

Lightweight tags are simply references to a commit object and are usually considered private to a repository. These tags do not create a permanent object in the object store. An annotated tag is more substantial and creates an object. It contains a message, supplied by you, and can be digitally signed using a GnuPG key according to RFC4880.

Git treats both lightweight and annotated tag names equivalently for the purposes of naming a commit. However, by default, many Git commands work only on annotated
tags, because they are considered “permanent” objects.

You create an annotated, unsigned tag with a message on a commit using the git tag command:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git tag -m "Tag version 1.0" V1.0 7af3c0256

How to get the sha1 hash of your tag?? its using rev-parse command

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git rev-parse V1.0
ae0b6a71736d52db8e6bd4b48023d35884a9ad00

check the contents of Tag object again with cat-file -p command

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git cat-file -p ae0b6a7173
object 7af3c02564043816e0e4a2866ece6e2f0810f160
type commit
tag V1.0
tagger Sivanesan G <nesan.committer@gmail.com> 1764346449 +0530

Tag version 1.0

Usually, Git tags a particular commit as named by some branch. Note that this behavior is notably different from that of other VCSs. Git usually tags a commit object, which points to a tree object, which encompasses the total state of the entire hierarchy of files and directories within your repository.

in this case Tag ae0b6a7173 points to  commit 7af3c0256 which inturn points to Tree 492413269 that spans multiple files. Thus, the tag simultaneously applies to all files of that tree.

This is unlike CVS, for example, which will apply a tag to each individual file and then rely on the collection of all those tagged files to reconstitute a whole tagged revision. And whereas CVS lets you move the tag on an individual file, Git requires a new commit, encompassing the file state change, onto which the tag will be moved.

File Management and the Index 

When you manage your code with Git, you edit in your working directory, accumulate changes in your index, and commit whatever has amassed in the index as a single changeset. You can think of Git’s index as a set of intended or prospective modifications. You add, remove, move, or repeatedly edit files right up to the culminating commit, which actualizes the accumulated changes in the repository. Most of the critical work actually precedes the commit step.

Remember, a commit is a two-step process: stage your changes and commit the changes. An alteration found in the working directory but not in the index isn’t staged and thus can’t be committed.
a) For convenience, Git allows you to combine the two steps when you add or change a file:
$ git commit index.html

b) But if you move or remove a file, you don’t have that luxury. The two steps must then be separate:
$ git rm index.html
$ git commit

It’s All About the Index

Git’s index doesn’t contain any file content; it simply tracks what you want to commit. When you run git commit, Git checks the index rather than your working directory to discover what to commit. Although many of Git’s “porcelain” (higher level) commands are designed to hide the details of the index from you and make your job easier, it is still important to keep the index and its state in mind.

You can query the state of the index at any time with the command git status. It explicitly calls out what files Git considers staged. You can also peer into the internal state of Git with “plumbing” commands such as git ls-files.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   hello.txt
        new file:   subdir/hello.txt
		
ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git ls-files
hello.txt
subdir/hello.txt

You’ll also likely find the git diff command useful during staging. This command can display two different sets of changes: git diff displays the changes that remain in your working directory and are not staged; git diff --cached shows changes that are staged and will therefore contribute to your
next commit.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git diff

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/checkGitFolder (master)
$ git diff --cached
diff --git a/hello.txt b/hello.txt
new file mode 100644
index 0000000..3b18e51
--- /dev/null
+++ b/hello.txt
@@ -0,0 +1 @@
+hello world
diff --git a/subdir/hello.txt b/subdir/hello.txt
new file mode 100644
index 0000000..3b18e51
--- /dev/null
+++ b/subdir/hello.txt
@@ -0,0 +1 @@
+hello world

You can use both variations of git diff to guide you through the process of staging changes. Initially, git diff is a large set of all modifications, and --cached is empty. As you stage, the former set will shrink and the latter set will grow. If all your working changes are staged and ready for a commit, the --cached will be full and git diff will show nothing. That is as you see in the output above its all ready to commit.

File Classifications in Git

Git classifies your files into three groups: tracked, ignored, and untracked.

Tracked : A tracked file is any file already in the repository or any file that is staged in the index. To add a new file somefile to this group, run git add somefile.

Ignored : An ignored file must be explicitly declared invisible or ignored in the repository even though it may be present within your working directory. A software project tends to have a good number of ignored files. Common ignored files include temporary and scratch files, personal notes, compiler output, and most files generated automatically during a build. Git maintains a default list of files to ignore, and you can configure your repository to recognize others.

Untracked : An untracked file is any file not found in either of the previous two categories. Git considers the entire set of files in your working directory and subtracts both the tracked files and the ignored files to yield what is untracked.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ mkdir L05_fileCategory

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ cd L05_fileCategory/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory
$ git init
Initialized empty Git repository in C:/Users/ADMIN/git_repo/L05_fileCategory/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)

Initially, there are no files and the tracked, ignored, and untracked sets are empty. Once you create data, git status reports a single, untracked file. Create a file named data. then check status data becomes untracked file.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ echo "New data" > data

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        data

nothing added to commit but untracked files present (use "git add" to track)

To have Git ignore a file within a directory, simply add that file’s name to the special file .gitignore:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ touch junkdata.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        data
        junkdata.txt

nothing added to commit but untracked files present (use "git add" to track)

Add junkdata.txt to .gitignore file to make it ignored file

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ echo junkdata.txt > .gitignore

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        data

nothing added to commit but untracked files present (use "git add" to track)

Using git add

The command git add stages a file. In terms of Git’s file classifications, if a file is untracked, then git add converts that file’s status to tracked. When git add is used on a directory name, all of the files and subdirectories beneath it are staged recursively.

start tracking both files data and .gitignore, once added both files are in stage. Staging a file is also called caching a file2 or “putting a file in the index.”.
the moment you issued git add the file was copied into the object store (folder) and indexed by its resulting SHA1 name.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git add data .gitignore

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   .gitignore
        new file:   data

To check the staged files and the hash value of those files use git ls-files --stage

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git ls-files --stage
100644 5b6115fc486164c05160fa1563618f4879a79d17 0       .gitignore
100644 534469f67ae5ce72a7a274faf30dee3c2ea1746d 0       data

Most of the day-to-day changes within your repository will likely be simple edits. After any edit and before you commit your changes, run git add to update the index with the absolute latest and greatest version of your file. If you don’t, you’ll have two different versions of the file: one captured in the object store and referenced from the index, and the other in your working directory.

To continue the example, let’s change the file data so it’s different from the one in the index and use the arcane git hash-object file command (which you’ll hardly ever invoke directly) to directly compute and print the SHA1 hash for the new version.

# edit "data" to contain...
$ cat data
New data
And some more data now

Check hash value of the data file with below command 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git hash-object data
cb91950710e98fd3b9270e0269fdcd92f1b062f7

you see the hash value is cb91950710e98fd3b9270e0269fdcd92f1b062f7 in workspace but in the stage its 534469f67ae5ce72a7a274faf30dee3c2ea1746d. we have different versions of the file in stage and work space now. 
So Let’s update the index to contain the new version of the file:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git add data

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git ls-files --stage
100644 5b6115fc486164c05160fa1563618f4879a79d17 0       .gitignore
100644 cb91950710e98fd3b9270e0269fdcd92f1b062f7 0       data

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)

Now both files in work space and the object store are same with same hash value check that

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L05_fileCategory (master)
$ git hash-object data
cb91950710e98fd3b9270e0269fdcd92f1b062f7

The index now has the updated version of the file. Again, “the file data has been staged,” or speaking loosely, “the file data is in the index.” 
In any event, the important thing to remember is that the version of a file in your working directory can be out of sync with the version staged in the index. When it comes time to make a commit, Git uses the version in the index. So ALWAYS index any changed file before you commit.

Some Notes on Using git commit

Using git commit --all

The -A or --all option to git commit causes it to automatically stage all unstaged, tracked file changes—including removals of tracked files from the working copy—
before it performs the commit.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ mkdir L06_commitall

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo
$ cd L06_commitall/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall
$ git init
Initialized empty Git repository in C:/Users/ADMIN/git_repo/L06_commitall/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "something" >> ready.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "nothing" > notready.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git add ready.txt notready.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git commit -m setup1
[master (root-commit) fe109ad] setup1
 2 files changed, 2 insertions(+)
 create mode 100644 notready.txt
 create mode 100644 ready.txt
 
# Modify file "ready.txt" and "git add" it to the index

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "somemore" >> ready.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ cat ready.txt
something
somemore

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git add ready.txt

# Modify file "notready.txt", leaving it unstaged

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "unsaved data" >> notready.txt

# create a subfolder newsubdir_notadded also create a file inside, leave it unindexed 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ mkdir newsubdir_notadded

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "file in sub" ./newsubdir_notadded/fileinsub.txt
file in sub ./newsubdir_notadded/fileinsub.txt

# check status

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   ready.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   notready.txt

Only ready.txt is indexed to commit notready.txt is not yet indexed, the new subfolder is not even in the untracked list so it will not be commited even with commit -A option, but when we use commit -A the modified file but not-staged file notready.txt will be commtied .

However, if you run git commit --all, Git recursively traverses the entire repository; stages all known, modified files and commits those.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git commit --all -m "test modified commit"
[master 2058714] test modified commit
 2 files changed, 2 insertions(+)

While Git recursively traverses the repository looking for modified and removed files, the completely new file subdir/ directory and all of its files do not become part of the commit. If you do not directly supply a log message on the command line, Git runs an editor and prompts you to write one. The editor chosen is selected from your configuration. 

Using git rm

The command git rm is, naturally the inverse of git add. It removes a file from both the repository and the working directory. Git will remove a file only from the index or from the index and working directory simultaneously. Git will not remove a file just from the working directory; the regular rm command may be used for that purpose.

Removing a file from your directory and the index does not remove the file’s existing history from the repository. Any versions of the file that are part of its history already committed in the repository remain in the object store and retain that history.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "just rm test" > rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)  ## you cant remove a file that is not yet added or in repo already
$ git rm rmtest.txt
fatal: pathspec 'rmtest.txt' did not match any files

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo > "indexed RM" > rmindexed.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git add rmindexed.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git commit rmindexed.txt -m "to test RM"
[master bc45e0e] to test RM
 1 file changed, 1 insertion(+)
 create mode 100644 rmindexed.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ ls
'indexed RM'   newsubdir_notadded/   notready.txt   ready.txt   rmindexed.txt   rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git rm rmindexed.txt
rm 'rmindexed.txt'

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   # git rm removed from the working folder and the repository but to make it permenant you need to commit
$ ls
'indexed RM'   newsubdir_notadded/   notready.txt   ready.txt   rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git commit -m "removed indexed.txt"
[master 784d342] removed indexed.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 rmindexed.txt

Before Git removes a file, it checks to make sure the version of the file in the working directory matches the latest version in the current branch (the version that Git commands call the HEAD). This verification precludes the accidental loss of any changes (due to your editing) that may have been made to the file.
Use git rm -f to force the removal of your file. Force is an explicit mandate and removes the file even if you have altered it since your last commit.



just to remove the file from the index alone but not from the working space use git rm --cached <filename>

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "just cached" > rmcached.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git add rmcached.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   rmcached.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        indexed RM
        rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git ls-files --stage
100644 8a633d54afbd39c750f2251ea80dc44392f62955 0       notready.txt
100644 38428aa8c8878da9bd4482e2c511d712ced59a21 0       ready.txt
100644 cdd95ac7d3bd43741b3bc46ade48bf0b7a73e139 0       rmcached.txt


ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git rm --cached rmcached.txt
rm 'rmcached.txt'

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## file is removed from index but check below its present in workspace
$ git ls-files --stage
100644 8a633d54afbd39c750f2251ea80dc44392f62955 0       notready.txt
100644 38428aa8c8878da9bd4482e2c511d712ced59a21 0       ready.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## file is still present in workspace 
$ ls
'indexed RM'   newsubdir_notadded/   notready.txt   ready.txt   rmcached.txt   rmtest.txt

Whereas git rm --cached removes the file from the index and leaves it in the working directory, git rm removes the file from both the index and the working directory. Using git rm --cached to make a file untracked while leaving a copy in the working directory is dangerous, because you may forget that it is no
longer being tracked. Using this approach also overrides Git’s check that the working file’s contents are current. Be careful.

rmcached.txt is in untracked state now.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        indexed RM
        rmcached.txt
        rmtest.txt

create a file rmforce.txt, after commit, try to edit the file and try just rm to see error then use -f force option.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "rm force option" > rmforce.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git add rmforce.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git commit rmforce.txt -m "change of file with force rm option"
[master 906acd9] change of file with force rm option
 1 file changed, 1 insertion(+)
 create mode 100644 rmforce.txt

now edit the file and add new line

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "additional line" >> rmforce.txt

# check content in the workspace 

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ cat rmforce.txt
rm force option
additional line

Get the hash for the same file in the repo, list the files in repo first

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## get the hash of any file in repo
$ git ls-tree -r HEAD
100644 blob 8a633d54afbd39c750f2251ea80dc44392f62955    notready.txt
100644 blob 38428aa8c8878da9bd4482e2c511d712ced59a21    ready.txt
100644 blob d1ed89be846033ec4f7d8629427c60c13f3194c7    rmforce.txt

now check the contents of the file in repo with cat-file command

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)    ## Has only one line
$ git cat-file -p d1ed89be846033ec4f7d8629427c60c13f3194c7        
rm force option

Now try to use just rm command. which means the file in workspace is updated but the file in repo is not updated its older version

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## get error that local file is modified but repo file is not same
$ git rm rmforce.txt
error: the following file has local modifications:
    rmforce.txt
(use --cached to keep the file, or -f to force removal)

git status also clearly shows the rmforce.txt is being modified in workspace

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   rmforce.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        indexed RM
        rmcached.txt
        rmtest.txt

use the -f to force removal for file from both workspace and repo

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git rm -f rmforce.txt
rm 'rmforce.txt'

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## file is removed from local
$ ls
'indexed RM'   newsubdir_notadded/   notready.txt   ready.txt   rmcached.txt   rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## file is still in repo until next commit
$ git ls-tree -r HEAD
100644 blob 8a633d54afbd39c750f2251ea80dc44392f62955    notready.txt
100644 blob 38428aa8c8878da9bd4482e2c511d712ced59a21    ready.txt
100644 blob d1ed89be846033ec4f7d8629427c60c13f3194c7    rmforce.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## Commit removes the file from repo
$ git commit -m "force rm success"
[master 8b71232] force rm success
 1 file changed, 1 deletion(-)
 delete mode 100644 rmforce.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## repo dont have rmforce.txt now
$ git ls-tree -r HEAD
100644 blob 8a633d54afbd39c750f2251ea80dc44392f62955    notready.txt
100644 blob 38428aa8c8878da9bd4482e2c511d712ced59a21    ready.txt

when you wrongly remove the file in workspace you can take a copy from repo with checkout command

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git rm ready.txt
rm 'ready.txt'

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## file deleted in the workspace
$ ll
total 3
-rw-r--r-- 1 ADMIN 197121  0 Nov 29 12:43 'indexed RM'
drwxr-xr-x 1 ADMIN 197121  0 Nov 29 12:14  newsubdir_notadded/
-rw-r--r-- 1 ADMIN 197121 21 Nov 29 12:14  notready.txt
-rw-r--r-- 1 ADMIN 197121 12 Nov 29 12:47  rmcached.txt
-rw-r--r-- 1 ADMIN 197121 13 Nov 29 12:41  rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## get a copy from repo into workspace
$ git checkout HEAD -- ready.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## file present in workspace now
$ ll
total 4
-rw-r--r-- 1 ADMIN 197121  0 Nov 29 12:43 'indexed RM'
drwxr-xr-x 1 ADMIN 197121  0 Nov 29 12:14  newsubdir_notadded/
-rw-r--r-- 1 ADMIN 197121 21 Nov 29 12:14  notready.txt
-rw-r--r-- 1 ADMIN 197121 19 Nov 29 15:18  ready.txt
-rw-r--r-- 1 ADMIN 197121 12 Nov 29 12:47  rmcached.txt
-rw-r--r-- 1 ADMIN 197121 13 Nov 29 12:41  rmtest.txt

Using git mv

Suppose you need to move or rename a file. You may use a combination of git rm on the old file and git add on the new file, or you may use git mv directly. Given a
repository with a file named stuff that you want to rename newstuff, the following sequences of commands are equivalent Git operations:

$ mv stuff newstuff
$ git rm stuff
$ git add newstuff

or

$ git mv stuff newstuff

In both cases, Git removes the pathname stuff from the index, adds a new pathname newstuff, keeps the original content for stuff in the object store, and reassociates that content with the pathname newstuff.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ echo "stuff to move" > stuff.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git add stuff.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git commit -m "add stuff.txt"
[master 5615025] add stuff.txt
 1 file changed, 1 insertion(+)
 create mode 100644 stuff.txt
 
ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git mv stuff.txt newstuff.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   ## check status after rename before commit
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        renamed:    stuff.txt -> newstuff.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        indexed RM
        rmcached.txt
        rmtest.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)  ## commit the move - rename of file
$ git commit -m "moved to new stuff"
[master a1fef5f] moved to new stuff
 1 file changed, 0 insertions(+), 0 deletions(-)
 rename stuff.txt => newstuff.txt (100%)

when check history with log command only the details of the current file is shown not the full history is shown

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log newstuff.txt
commit a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:26:24 2025 +0530

    moved to new stuff
	
to Get the full history use the --follow option shows fulle history of the renamed file

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log --follow newstuff.txt
commit a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:26:24 2025 +0530

    moved to new stuff

commit 56150255cac6fae11f176d955aeb220013e314cd
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:24:26 2025 +0530

    add stuff.txt

One of the classic problems with VCSs is that renaming a file can cause them to lose track of a file’s history. Git preserves this information even after a rename.

The .gitignore File

Earlier in this chapter you saw how to use the .gitignore file to pass over main.o, an irrelevant file. As in that example, you can skip any file by adding its name to .gitignore in the same directory. Additionally, you can ignore the file everywhere by adding it to the .gitignore file in the topmost directory of your repository.

But Git also supports a much richer mechanism. A .gitignore file can contain a list of filename patterns that specify what files to ignore. The format of .gitignore is as follows:

• Blank lines are ignored, and lines starting with a pound sign (#) can be used for comments. However, the # does not represent a comment if it follows other text
on the line.
• A simple, literal filename matches a file in any directory with that name. 
• A directory name is marked by a trailing slash character (/). This matches the named directory and any subdirectory but does not match a file or a symbolic link.
• A pattern containing shell globbing characters, such as an asterisk (*), is expanded as a shell glob pattern. Just as in standard shell globbing, the match cannot extend across directories and so an asterisk can match only a single file or directory name. But an asterisk can still be part of a pattern that includes slashes to specify directory names (e.g., debug/32bit/*.o).
• An initial exclamation point (!) inverts the sense of the pattern on the rest of the line. Additionally, any file excluded by an earlier pattern but matching an inversion rule is included. An inverted pattern overrides lower precedence rules.

Furthermore, Git allows you to have a .gitignore file in any directory within your repository. Each file affects its directory and all subdirectories. The .gitignore rules also cascade: you can override the rules in a higher directory by including an inverted pattern (using the initial !) in one of the subdirectories.

• Patterns specified on the command line.
• Patterns read from .gitignore in the same directory.
• Patterns in parent directories, proceeding upward. Hence, the current directory’s
patterns overrule the parents’ patterns, and the parents close to the current
directory take precedence over higher parents.
• Patterns from the .git/info/exclude file.
• Patterns from the file specified by the configuration variable core.excludefile.

Because a .gitignore is treated as a regular file within your repository, it is copied during clone operations and applies to all copies of your repository. In general, you should place entries into your version controlled .gitignore files only if the patterns apply to all derived repositories universally.

Files flow from the work space -> index -> repo (object store) 

when ever a file is edited in workspace and add command is given to add it to index, Git first takes the version of file1 from the working directory,
computes a SHA1 hash ID (bd71363) for its contents, and places that ID in the object store. Next, Git records in the index that the pathname file1 has been updated to the new bd71363 SHA1.

Whenever a file is edited in the workspace (workspace is considered as dirty).
once the changed file is add, but not yet commited (the index is considered dirty with respect to HEAD because it differs from the tree recorded in the object store for the HEAD commit of the master branch.). 

Finally, after all changes have been staged in the index, a commit applies them to the repository. the commit initiates three steps. 
First, the virtual tree object that is the index gets converted into a real tree object and placed into the object store under its SHA1 name. 
Second, a new commit object is created with your log message. The new commit points to the newly created tree object and also to the previous or parent commit. 
Third, the master branch ref is moved from the most recent commit to the newly created commit object, becoming the new master HEAD.

Commits

In Git, a commit is used to record changes to a repository. 
 
When a commit occurs, Git records a snapshot of the index and places that snapshot in the object store. This snapshot does not contain a copy of every file and directory in the index, because such a strategy would require enormous and prohibitive amounts of storage. Instead, Git compares the current state of the index to the previous snapshot and so derives a list of affected files and directories. Git creates new blobs for any file that has changed and new trees for any directory that has changed, and it reuses any blob or tree object that has not changed.

Commit snapshots are chained together, with each new snapshot pointing to its predecessor. Over time, a sequence of changes is represented as a series of commits.
There is a one-to-one correspondence between a set of changes in the repository and a commit: A commit is the only method of introducing changes to a repository, and any change in the repository must be introduced by a commit. This mandate provides accountability. Under no circumstance should repository data change without a record of the change!

Although commits are most often introduced explicitly by a developer, Git itself can introduce commits. As you’ll see, a merge operation causes a commit in the repository in addition to any commits made by users before the merge. However, don’t hesitate to introduce commits! Git is well-suited to frequent commits and provides a rich set of commands for manipulating them.

Atomic Changesets

Every Git commit represents a single, atomic changeset with respect to the previous state. Regardless of the number of directories, files, lines, or bytes that change with a commit,1 either all changes apply or none do. A commit snapshot represents the total set of modified files and directories. It must represent one tree state or the other, and a changeset between two state snapshots represents a complete treeto-tree transformation.

Identifying Commits

Whether you code individually or with a team, identifying individual commits is an essential task. For example, to create a branch, you must choose a commit from which to diverge; to compare code variations, you must specify two commits; and to edit the commit history, you must provide a collection of commits. In Git, you can refer to every commit via an explicit or an implied reference. The unique, 40-hexadecimal-digit SHA1 commit ID is an explicit reference, whereas HEAD, which always points to the most recent commit, is an implied reference. 

to list all the commits that happened in a repo you can use below command

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log --reverse
commit fe109adeb2f34c7187c4a85d598b07f20b52ea3a
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 12:11:59 2025 +0530

    setup1

commit 2058714bba28f487ccd456e218468e852b376d28
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 12:21:47 2025 +0530

    test modified commit

commit bc45e0eb8970a70647c1db66faf6a093fbfe831f
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 12:43:38 2025 +0530

    to test RM

commit 784d342e0bfcb88119b9ab1e23c824ef3aaf3c9b
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 12:45:51 2025 +0530

    removed indexed.txt

commit 906acd940ed829ce6ac7242a78e49695357f604f
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 14:47:58 2025 +0530

    change of file with force rm option

commit 8b712324f8c477fb661d9dd8fe8eccf39ee8e0f4
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:11:52 2025 +0530

    force rm success

commit 56150255cac6fae11f176d955aeb220013e314cd
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:24:26 2025 +0530

    add stuff.txt

commit a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:26:24 2025 +0530

    moved to new stuff
	
to make it short you can use he --oneline option

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log --reverse --oneline
fe109ad setup1
2058714 test modified commit
bc45e0e to test RM
784d342 removed indexed.txt
906acd9 change of file with force rm option
8b71232 force rm success
5615025 add stuff.txt
a1fef5f (HEAD -> master) moved to new stuff

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)   #another variation with -# option 
$ git log -2 --pretty=oneline HEAD
a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master) moved to new stuff
56150255cac6fae11f176d955aeb220013e314cd add stuff.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log -10 --pretty=oneline HEAD
a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master) moved to new stuff
56150255cac6fae11f176d955aeb220013e314cd add stuff.txt
8b712324f8c477fb661d9dd8fe8eccf39ee8e0f4 force rm success
906acd940ed829ce6ac7242a78e49695357f604f change of file with force rm option
784d342e0bfcb88119b9ab1e23c824ef3aaf3c9b removed indexed.txt
bc45e0eb8970a70647c1db66faf6a093fbfe831f to test RM
2058714bba28f487ccd456e218468e852b376d28 test modified commit
fe109adeb2f34c7187c4a85d598b07f20b52ea3a setup1

Absolute Commit Names 
The most rigorous name for a commit is its hash identifier. The hash ID is an absolute name, meaning it can only refer to exactly one commit. It doesn’t matter where the commit is among the entire repository’s history; the hash ID always identifies the same commit.

Each commit ID is globally unique, not just for one repository but for any and all repositories. For example, if a developer writes you with reference to a particular commit ID in his repository and if you find the same commit in your repository, then you can be certain that you both have the same commit with the same content.

Furthermore,because the data that contribute to a commit ID contain the state of the whole repository tree as well as the prior commit state, by an inductive argument, an even stronger claim can be made: You can be certain that both of you are discussing the same complete line of development leading up to and including the commit.

BRANCH : A branch in Git is a separate line of development that allows you to work on new features, bug fixes, or experiments without affecting the main codebase. Each branch contains its own set of commits, so changes made in one branch do not interfere with the main project until you merge them.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log -1 --pretty=oneline HEAD
a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master) moved to new stuff

Because a 40-hexadecimal-digit SHA1 number makes for a tedious and error-prone entry, Git allows you to shorten this number to a unique prefix within a repository’s object database.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log -1 --pretty=oneline a1fef5
a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master) moved to new stuff

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)  ## very short tag
$ git log -1 --pretty=oneline a1f
fatal: ambiguous argument 'a1f': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'

refs and symrefs

A ref is an SHA1 hash ID that refers to an object within the Git object store. Although a ref may refer to any Git object, it usually refers to a commit object. A symbolic reference, or symref, is a name that indirectly points to a Git object. It is still just a ref.

Local topic branch names, remote tracking branch names, and tag names are all refs. Each symbolic ref has an explicit, full name that begins with refs/ and each is stored hierarchically within the repository in the .git/refs/ directory. There are basically three different namespaces represented in refs/: refs/heads/ref for your local branches, refs/remotes/ref for your remote tracking branches, and refs/tags/ref for your tags.

For example, a local topic branch named dev is really a short form of refs/heads/dev. Remote tracking branches are in the refs/remotes/ namespace, so origin/master really names refs/remotes/origin/master. And finally, a tag such as v2.6.23 is short for refs/ tags/v2.6.23.

You can use either a full ref name or its abbreviation, but if you have a branch and a tag with the same name, Git applies a disambiguation heuristic and uses the first match according to this list from the git rev-parse manpage:

The first rule is usually just for a few refs described later: HEAD, ORIG_HEAD, FETCH_HEAD, CHERRY_PICK_HEAD, and MERGE_HEAD.

Technically, the name of the Git directory, .git, can be changed. Thus, Git’s internal documentation uses the variable $GIT_DIR instead of the literal .git.

Git maintains several special symrefs automatically for particular purposes. They can be used anywhere a commit is used.

HEAD : 
HEAD always refers to the most recent commit on the current branch. When you change branches, HEAD is updated to refer to the new branch’s latest commit.
ORIG_HEAD : 
Certain operations, such as merge and reset, record the previous version of HEAD in ORIG_HEAD just prior to adjusting it to a new value. You can use ORIG_HEAD to recover or revert to the previous state or to make a comparison.
FETCH_HEAD : 
When remote repositories are used, git fetch records the heads of all branches fetched in the file .git/FETCH_HEAD. FETCH_HEAD is a shorthand for the head of the last branch fetched and is valid only immediately after a fetch operation. Using this symref, you can find the HEAD of commits from git fetch even if an anonymous
fetch that doesn’t specifically name a branch is used
MERGE_HEAD : 
When a merge is in progress, the tip of the other branch is temporarily recorded in the symref MERGE_HEAD. In other words, MERGE_HEAD is the commit that is being merged into HEAD.

Relative Commit Names

Git also provides mechanisms for identifying a commit relative to another reference, commonly the tip of a branch.

You’ve seen some of these names already, such as master and master^, where master^ always refers to the penultimate commit on the master branch. There are others as well: you can use master^^, master~2, and even a complex name like master~10^2~2^2.

Except for the first root commit,2 each commit is derived from at least one earlier commit and possibly many, where direct ancestors are called parent commits. For a commit to have multiple parent commits, it must be the result of a merge operation. As a result, there will be a parent commit for each branch contributing to a merge commit.

Within a single generation, the caret is used to select a different parent. Given a commit C, C^1 is the first parent, C^2 is the second parent, C^3 is the third parent

The tilde is used to go back before an ancestral parent and select a preceding generation. Again, given the commit C, C~1 is the first parent, C~2 is the first grandparent, and C~3 is the first great-grandparent.

You might also notice that both C^1 and C~1 refer to the first parent;

Git supports other abbreviations and combinations as well. The abbreviated forms C^ and C~ are the same as C^1 and C~1, respectively. Also, C^^ is the same as C^1^1 and, because that means the “first parent of the first parent of commit C,” it refers to the same commit as C~2.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show-branch
[master] moved to new stuff

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master) gives same output as listing all commits as in below command.
$ git show-branch --more=10
[master] moved to new stuff
[master^] add stuff.txt
[master~2] force rm success
[master~3] change of file with force rm option
[master~4] removed indexed.txt
[master~5] to test RM
[master~6] test modified commit
[master~7] setup1

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log -10 --pretty=oneline
a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master) moved to new stuff
56150255cac6fae11f176d955aeb220013e314cd add stuff.txt
8b712324f8c477fb661d9dd8fe8eccf39ee8e0f4 force rm success
906acd940ed829ce6ac7242a78e49695357f604f change of file with force rm option
784d342e0bfcb88119b9ab1e23c824ef3aaf3c9b removed indexed.txt
bc45e0eb8970a70647c1db66faf6a093fbfe831f to test RM
2058714bba28f487ccd456e218468e852b376d28 test modified commit
fe109adeb2f34c7187c4a85d598b07f20b52ea3a setup1

The command git rev-parse is the final authority on translating any form of commit name—tag, relative, shortened, or absolute—into an actual, absolute commit hash ID within the object database.

Commit History

Viewing Old Commits
The primary command to show the history of commits is git log. It has more options, parameters, bells, whistles, colorizers, selectors, formatters, and doodads than the fabled ls.

In its parameterless form, git log acts like git log HEAD, printing the log message associated with every commit in your history that is reachable from HEAD. Changes are shown starting with the HEAD commit and work back through the graph. They are likely to be in roughly reverse chronological order, but recall Git adheres to the commit graph, not time, when traveling back over the history.

All three below commands are same 

git log
git log HEAD
git log master

The logs are authoritative, but rolling back through the entire commit history of your repository is likely not very practical or meaningful. Typically, a limited history is more informative. One technique to constrain history is to specify a commit range using the form since..until. Given a range, git log shows all commits following since running through until. Here’s an example.

git log --pretty=short --abbrev-commit master  ## short output with Date of commit

git log --pretty=short --abbrev-commit master~12..master~10  ##   Here, git log shows the commits between master~12 and master~10, or the 10th and 11th prior commits on the master branch.

The previous example also introduces two formatting options, --pretty=short and --abbrev-commit. The former adjusts the amount of information about each commit and has several variations, including oneline, short, and full. The latter simply requests that hash IDs be abbreviated.

Use the -p option to print the patch, or changes, introduced by the commit.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git log -1 -p
commit a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:26:24 2025 +0530

    moved to new stuff

diff --git a/stuff.txt b/newstuff.txt
similarity index 100%
rename from stuff.txt
rename to newstuff.txt

The --stat option enumerates the files changed in a commit and tallies how many lines were modified in each file.

git log --pretty=short --stat

Another command to display objects from the object store is git show. You can use it to see a commit:

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show HEAD
commit a1fef5f9f38d55b50c5b386185dbc0cdc51bb0d7 (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:26:24 2025 +0530

    moved to new stuff

diff --git a/stuff.txt b/newstuff.txt
similarity index 100%
rename from stuff.txt
rename to newstuff.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show HEAD~2
commit 8b712324f8c477fb661d9dd8fe8eccf39ee8e0f4
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:11:52 2025 +0530

    force rm success

diff --git a/rmforce.txt b/rmforce.txt
deleted file mode 100644
index d1ed89b..0000000
--- a/rmforce.txt
+++ /dev/null
@@ -1 +0,0 @@
-rm force option

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show HEAD~2
commit 8b712324f8c477fb661d9dd8fe8eccf39ee8e0f4
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 15:11:52 2025 +0530

    force rm success

diff --git a/rmforce.txt b/rmforce.txt
deleted file mode 100644
index d1ed89b..0000000
--- a/rmforce.txt
+++ /dev/null
@@ -1 +0,0 @@
-rm force option


ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show HEAD~8
fatal: ambiguous argument 'HEAD~8': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show HEAD~7
commit fe109adeb2f34c7187c4a85d598b07f20b52ea3a
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Sat Nov 29 12:11:59 2025 +0530

    setup1

diff --git a/notready.txt b/notready.txt
new file mode 100644
index 0000000..9dafe9b
--- /dev/null
+++ b/notready.txt
@@ -0,0 +1 @@
+nothing
diff --git a/ready.txt b/ready.txt
new file mode 100644
index 0000000..deba01f
--- /dev/null
+++ b/ready.txt
@@ -0,0 +1 @@
+something

or to see a specific blob object contents we can use below command master is branch : followed by blob object name

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/L06_commitall (master)
$ git show master:notready.txt
nothing
unsaved data

Commit Graphs

Each commit introduces a tree object that represents the entire repository. Therefore, a commit can be pictured as just a name. Git makes use of a special graph called a directed acyclic graph (DAG). A DAG has two important properties. First, the edges within the graph are all directed from one node to another. Second, starting at any node in the graph, there is no path along the directed edges that leads back to the starting node.

Git implements the history of commits within a repository as a DAG. In the commit graph, each node is a single commit, and all edges are directed from one descendant node to another parent node, forming an ancestor relationship.
Merge commits merge the code from two branches and creates a commit ID, mostly merge happens with master branch.

gitk command helps with UI which can display details of commit graph with all details along with changes in each commit. 

what you must know to understand the DAG of commits. First of all, each commit can have zero or more parents, as follows:

• Normal commits have exactly one parent, which is the previous commit in the history. When you make a change, your change is the difference between your new commit and its parent.
• There is usually only one commit with zero parents: the initial commit, which appears at the bottom of the graph.
• A merge commit, such as the one at the top of the graph, has more than one parent.
• A commit with more than one child is the place where history began to diverge and formed a branch. There is no permanent record of branch start points, but Git can algorithmically determine them via the git merge-base command.

Commit Ranges

Many Git commands allow you to specify a commit range. In its simplest instantiation, a commit range is a shorthand for a series of commits. More complex forms allow you to include and exclude commits.

A range is denoted with a double-period (..), as in start..end, where start and end may be specified as symbolic reference as under topic refs and symrefs or with branch names. 
The example used the range master~12..master~10 to specify the 11th and 10th prior commits on the master branch. Branch M is shown over a portion of its commit history that is linear, Recall that time flows left to right, so M~14 is the oldest commit shown, M~9 is recent commit and M~1 is the most recent commit. The range M~12..M~10 represents two commits, the 11th and 10th oldest commits, This range does not include M~12. Because “the commit end is included” whereas “the commit start is excluded.” Usually this is simplified to just the phrase “in end but not start.”

When you specify a commit Y, to git log, you are actually requesting Git to show the log for all commits that are reachable from Y. You can exclude a specific commit X and all commits reachable from X with the expression ^X. Combining the two forms, git log ^X Y is the same as git log X..Y and might be paraphrased as “give me all commits that are reachable from Y and don’t give me any commit leading up to and including X.” The commit range X..Y is mathematically equivalent to ^X Y. You can also think of it as a set subtraction: Use everything leading up to Y minus everything leading up to and including X.

There are two other range permutations. If you leave either the start or end commits out of range, HEAD is assumed. Thus, ..end is equivalent to HEAD..end and start.. is equivalent to start..HEAD. Finally, just as start..end can be thought of as representing a set subtraction operation, the notation A...B (using three periods) represents the symmetric difference between A and B, or the set of commits that are reachable from either A or B but not from both. 

Pending - PAGE 78 to 82 read again and make notes

Finding Commits

Part of a good RCS is the support it provides for “archaeology” and investigating a repository. Git provides several mechanisms to help you locate commits that meet certain criteria within your repository.

Using git bisect

The git bisect command is a powerful tool for isolating a particular, faulty commit based on essentially arbitrary search criteria. It is well-suited to those times when you discover that something “wrong” or “bad” is affecting your repository and you know the code had been fine. For example, let’s say you are working on the Linux kernel and a test boot fails, but you’re positive the boot worked sometime earlier, perhaps last  week or at a previous release tag. In this case, your repository has transitioned from a known “good” state to a known “bad” state. But when? Which commit caused it to break? That is precisely the question git bisect is designed to help you answer.

The git bisect command is often used to isolate a particular commit that introduced some regression or bug into the repository. For example, if you were working on the Linux kernel, git bisect could help you find issues and bugs such as fails to compile, fails to boot, boots but can’t perform some task, or no longer has a desired performance characteristic. In all of these cases, git bisect can help you isolate and determine the exact commit that caused the problem.

The git bisect command systematically chooses a new commit in an ever decreasing range bounded by good behavior at one end and by bad behavior at the other. Eventually, the narrowing range will pinpoint the one commit that introduced the faulty behavior.

There is no need for you to do anything more than provide an initial good and bad commit and then repeatedly answer the question “Does this version work?” To start, you first need to identify a good commit and a bad commit. In practice, the bad version is often your current HEAD, because that’s where you are working when you suddenly noticed something wrong or were assigned a bug to fix.

Finding an initial good version can be a bit difficult, because it’s usually buried in your history somewhere. You can probably name or guess some version back in the history of the repository that you know works correctly. This may be a tagged release like v2.6.25 or some commit 100 revisions ago, master~100, on your master branch. Ideally, it is close to your bad commit (master~25 is better than master~100) and not buried too far in the past. In any event, you need to know or be able to verify that it is, in fact, a good commit.

It is essential that you start the git bisect process from a clean working directory. The process necessarily adjusts your working directory to contain various different versions of your repository. Starting with a dirty work space is asking for trouble; your working directory could easily be lost. Using a clone of the Linux kernel in our example, let’s tell Git to begin a search:

After initiating a bisection search, Git enters a bisect mode, setting up some state information for itself. Git employs a detached HEAD to manage the current checkedout version of the repository. This detached HEAD is essentially an anonymous branch that can be used to bounce around within the repository and point to different revisions as needed.

Once started, tell Git which commit is bad. Again, because this is typically your current version, you can simply default the revision to your current HEAD.4

# Tell git the HEAD version is broken
$ git bisect bad

Similarly, tell Git which version works:

$ git bisect good v2.6.27
Bisecting: 3857 revisions left to test after this
[cf2fa66055d718ae13e62451bb546505f63906a2] Merge branch 'for_linus'
   of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-2.6

Identifying a good and bad version delineates a range of commits over which a good to bad transition occurs. At each step along the way, Git will tell you how many revisions are in that range. Git also modifies your working directory by checking out a revision that is roughly midway between the good and bad end points. It is now up to you to answer the question: “Is this version good or bad?” Each time you answer this question, Git narrows the search space in half, identifies a new revision, checks it out, and repeats the “good or bad?” question.

Suppose this version is good: 

$ git bisect good
Bisecting: 1939 revisions left to test after this
[2be508d847392e431759e370d21cea9412848758] Merge git://git.infradead.org/mtd-2.6

Notice that 3,857 revisions have been narrowed down to 1,939. Let’s do a few more:

$ git bisect good
Bisecting: 939 revisions left to test after this
[b80de369aa5c7c8ce7ff7a691e86e1dcc89accc6] 8250: Add more OxSemi devices

$ git bisect bad
Bisecting: 508 revisions left to test after this
[9301975ec251bab1ad7cfcb84a688b26187e4e4a] Merge branch 'genirq-v28-for-linus'
of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip

In a perfect bisection run, it takes log2 of the original number of revision steps to narrow down to just one commit.

After another good and bad answer:
$ git bisect good
Bisecting: 220 revisions left to test after this
[7cf5244ce4a0ab3f043f2e9593e07516b0df5715] mfd: check for platform_get_irq() return value in sm501

$ git bisect bad
Bisecting: 104 revisions left to test after this
[e4c2ce82ca2710e17cb4df8eb2b249fa2eb5af30] ring_buffer: allocate
buffer page pointer

Throughout the bisection process, Git maintains a log of your answers along with their
commit IDs.
$ git bisect log
git bisect start
# bad: [49fdf6785fd660e18a1eb4588928f47e9fa29a9a] Merge branch
'for-linus' of git://git.kernel.dk/linux-2.6-block
git bisect bad 49fdf6785fd660e18a1eb4588928f47e9fa29a9a
# good: [3fa8749e584b55f1180411ab1b51117190bac1e5] Linux 2.6.27
git bisect good 3fa8749e584b55f1180411ab1b51117190bac1e5
# good: [cf2fa66055d718ae13e62451bb546505f63906a2] Merge branch 'for_linus'
of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-2.6
git bisect good cf2fa66055d718ae13e62451bb546505f63906a2
# good: [2be508d847392e431759e370d21cea9412848758] Merge
git://git.infradead.org/mtd-2.6
git bisect good 2be508d847392e431759e370d21cea9412848758
# bad: [b80de369aa5c7c8ce7ff7a691e86e1dcc89accc6] 8250: Add more
OxSemi devices
git bisect bad b80de369aa5c7c8ce7ff7a691e86e1dcc89accc6
# good: [9301975ec251bab1ad7cfcb84a688b26187e4e4a] Merge branch
'genirq-v28-for-linus' of
git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
git bisect good 9301975ec251bab1ad7cfcb84a688b26187e4e4a
# bad: [7cf5244ce4a0ab3f043f2e9593e07516b0df5715] mfd: check for
platform_get_irq() return value in sm501
git bisect bad 7cf5244ce4a0ab3f043f2e9593e07516b0df5715

If you get lost during the process, or if you just want to start over for any reason, type the git bisect replay command using the log file as input. If needed, this is an excellent mechanism to back up one step in the process and explore a different path.

Let’s narrow down the defect with five more “bad” answers:
$ git bisect bad
Bisecting: 51 revisions left to test after this
[d3ee6d992821f471193a7ee7a00af9ebb4bf5d01] ftrace: make it depend on DEBUG_KERNEL 

$ git bisect bad
Bisecting: 25 revisions left to test after this
[3f5a54e371ca20b119b73704f6c01b71295c1714] ftrace: dump out ftrace buffers to console on panic

$ git bisect bad
Bisecting: 12 revisions left to test after this
[8da3821ba5634497da63d58a69e24a97697c4a2b] ftrace: create _mcount_loc section

$ git bisect bad
Bisecting: 6 revisions left to test after this
[fa340d9c050e78fb21a142b617304214ae5e0c2d] tracing: disable tracepoints by default

$ git bisect bad
Bisecting: 2 revisions left to test after this
[4a0897526bbc5c6ac0df80b16b8c60339e717ae2] tracing: tracepoints, samples

You may use the git bisect visualize to visually inspect the set of commits still within the range of consideration. Git uses the graphical tool gitk if the DISPLAY environment variable is set. If not, then Git will use git log instead. In that case, --pretty=oneline might be useful, too.

$ git bisect visualize --pretty=oneline
fa340d9c050e78fb21a142b617304214ae5e0c2d tracing: disable tracepoints by default
b07c3f193a8074aa4afe43cfa8ae38ec4c7ccfa9 ftrace: port to tracepoints 
0a16b6075843325dc402edf80c1662838b929aff tracing, sched: LTTng instrumentation - scheduler
4a0897526bbc5c6ac0df80b16b8c60339e717ae2 tracing: tracepoints, samples
24b8d831d56aac7907752d22d2aba5d8127db6f6 tracing: tracepoints, documentation
97e1c18e8d17bd87e1e383b2e9d9fc740332c8e2 tracing: Kernel Tracepoints

Finally, when your bisection run is complete and you are finished with the bisection log and the saved state, it is vital that you tell Git that you have finished. As you may recall, the whole bisection process is performed on a detached HEAD:

$ git branch
* (no branch)
master

$ git bisect reset
Switched to branch "master"

$ git branch
* master

Running git bisect reset places you back on your original branch.

Using git blame

Another tool you can use to help identify a particular commit is git blame. This command tells you who last modified each line of a file and which commit made the change.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/linux (master)
$ git blame -L 35, init/version.c
Blaming lines: 100% (20/20), done.
3eb3c740f51c2 (Roman Zippel    2007-01-10 14:45:28 +0100 35) const char linux_proc_banner[] =
3eb3c740f51c2 (Roman Zippel    2007-01-10 14:45:28 +0100 36)    "%s version %s"
3eb3c740f51c2 (Roman Zippel    2007-01-10 14:45:28 +0100 37)    " (" LINUX_COMPILE_BY "@" LINUX_COMPILE_HOST ")"
3eb3c740f51c2 (Roman Zippel    2007-01-10 14:45:28 +0100 38)    " (" LINUX_COMPILER ") %s\n";
9afb719e7046c (Laura Abbott    2018-07-05 17:49:37 -0700 39)
9afb719e7046c (Laura Abbott    2018-07-05 17:49:37 -0700 40) BUILD_SALT;
1fdd7433a98a2 (Yonghong Song   2021-04-01 16:27:23 -0700 41) BUILD_LTO_INFO;
2df8220cc5113 (Masahiro Yamada 2022-08-28 11:39:53 +0900 42)
2df8220cc5113 (Masahiro Yamada 2022-08-28 11:39:53 +0900 43) /*
2df8220cc5113 (Masahiro Yamada 2022-08-28 11:39:53 +0900 44)  * init_uts_ns and linux_banner contain the build version and timestamp

Using Pickaxe

The -S option to git log is called pickaxe. That’s brute force archeology for you.

Wheareas git blame tells you about the current state of a file, git log -Sstring searches back through the history of a file’s diffs for the given string. By searching the actual diffs between revisions, this command can find commits that perform a change in both additions and deletions.

ADMIN@DESKTOP-O8I6CUH MINGW64 ~/git_repo/linux (master)
$ git log -Sinclude --pretty=oneline --abbrev-commit init/version.c
9edb4fd3d70a init/version.c: remove #include <generated/utsrelease.h>
2df8220cc511 kbuild: build init/built-in.a just once
561daaacb45e init/version.c: remove #include <linux/version.h>
5a704629f2c1 init: add "hostname" kernel parameter
1fdd7433a98a kbuild: add an elfnote for whether vmlinux is built with lto
9afb719e7046 kbuild: Add build salt to the kernel and modules
98f842e675f9 proc: Usable inode numbers for the namespace file descriptors.
cd354f1ae75e [PATCH] remove many unneeded #includes of sched.h
4865ecf1315b [PATCH] namespaces: utsname: implement utsname namespaces
63104eec234b kbuild: introduce utsrelease.h
1da177e4c3f4 (tag: v2.6.12-rc2) Linux-2.6.12-rc2

Each of the commits listed on the left (cd354f1, etc.) will either add or delete lines that contain the word include. Be careful, though. If a commit both adds and subtracts exactly the same number of instances of lines with your key phrase, that won’t be shown. The commit must have a change in the number of additions and deletions in order to count.

Branches

A branch is the fundamental means of launching a separate line of development within a software project. A branch is a split from a kind of unified, primal state, allowing development to continue in multiple directions simultaneously and, potentially, to produce different versions of the project. Often, a branch is reconciled and merged with other branches to reunite disparate efforts.

Git allows many branches and thus many different lines of development within a repository. Git’s branching system is lightweight and simple. Moreover, Git has firstrate support for merges. This chapter shows you how to select, create, view, and remove branches. It also provides some best practices, so your branches don’t twist.

Reasons for Using Branches

• A branch often represents an individual customer release. If you want to start version 1.1 of your project but you know that some of your customers want to stick with version 1.0, then keep the old version alive as a separate branch.
• A branch can encapsulate a development phase, such as the prototype, beta, stable, or bleeding-edge release. You can think of the version 1.1 release as a separate phase, too; the maintenance release.
• A branch can isolate the development of a single feature or research into a particularly complex bug. For example, you can introduce a branch for a well-defined and conceptually isolated task or to facilitate a merge of several branches prior to a release. It may seem like overkill to create a new branch just to fix one bug, but Git’s branching system encourages such small-scale use.
• An individual branch can represent the work of an individual contributor. Another branch—the “integration” branch—can be used specifically to unify efforts.

Git refers to a branch like those just listed as a topic branch or a development branch. The word “topic” simply indicates that each branch in the repository has a particular purpose. Git also has the notion of a tracking branch, or a branch to keep clones of a repository in sync.

Curiously, you can name a branch and a tag with the same name. If you do, you will have to use their full ref names to distinguish them. For example, you could use refs/ tags/v1.0 and refs/heads/v1.0. You may want to use the same name as a branch name during development and then convert it to a tag name at the conclusion of your development.

Tag serves as a stake in the ground and reference point. On the other hand, a branch is dynamic and moves with each commit you make. The branch name is designed to follow your continuing development.

Branch Names

The name you assign to a branch is essentially arbitrary, though there are some limitations. The default branch in a repository is named master and most developers keep the repository’s most robust and dependable line of development on that branch. There is nothing magic about the name master, except that Git introduces it during the initialization of a repository. If you prefer, you can rename or even delete the master branch, although it’s probably best practice to leave it alone.

To support scalability and categorical organization, you can create a hierarchical branch name that resembles a Unix pathname. For example, suppose you are part of a development team that fixes a multitude of bugs. It may be useful to place the development of each repair in a hierarchical structure, under the branch name bug, on separate branches named something like bug/pr-1023 and bug/pr-17. If you find you have many branches or are just terminally overorganized, you can use this slash syntax to introduce some structure to your branch names.

One reason to use hierarchical branch names is that Git, just like the Unix shell, supports wildcards. For instance, given the naming scheme bug/pr-1023 and bug/pr-17, you can select all bug branches at once with a clever and familiar shorthand.

git show-branch 'bug/*'

Dos and Don’ts in Branch Names

Branch names must conform to a few simple rules.
• You can use the forward slash (/) to create a hierarchical name scheme. However,
the name cannot end with a slash.
• The name cannot start with a minus sign (-).
• No slash-separated component can begin with a dot (.). A branch name such as
feature/.new is invalid.
• The name cannot contain two consecutive dots (..) anywhere.
• Further, the name cannot contain:
  — Any space or other whitespace character
  — A character that has special meaning to Git, including the tilde (~), caret (^), colon (:), question mark (?), asterisk (*), and open bracket ([)
  — An ASCII control character, which is any byte with a value lower than \040 octal, or the DEL character (\177 octal)

These branch name rules are enforced by the git check-ref-format plumbing command, and they are designed to ensure that each branch name is both easily typed and usable as a filename within the .git directory and scripts.

Using Branches

There may be many different branches within a repository at any given time, but there is at most one active or current branch. The active branch determines which files are checked out in the working directory. Furthermore, the current branch is often an implicit operand in Git commands, such as the target of the merge operation. By default, master is the active branch, but you can make any branch the current branch.

A branch allows the content of the repository to diverge in many directions, one per branch. Once a repository forks at least one branch, each commit is applied to one branch or the other, whichever is active. Each branch in a specific repository must have a unique name, and the name always refers to the most recent revision committed on that branch. The most recent commit on a branch is called the tip or head of the branch.

Git doesn’t keep information about where a branch originated. Instead, the branch name moves incrementally forward as new commits are made on the branch. Older commits must therefore be named by their hash or via a relative name such as dev~5. If you want to keep track of a particular commit—because it represents a stable point in the project, say, or is a version you want to test—you can explicitly assign it a lightweight tag name.

Repo -> Branch (branch name) -> commit (tag name) 

Because the original commit from which a branch was started is not explicitly identified, that commit (or its equivalent) can be found algorithmically using the name of the original branch from which the new branch forked:

$ git merge-base original-branch new-branch

A merge is the complement of a branch. When you merge, the content of one or more branches is joined with an implicit target branch. However, a merge does not eliminate any of the source branches or those branches’ names.

You can think of a branch name as a pointer to a particular (albeit evolving) commit. A branch includes the commits sufficient to rebuild the entire history of the project along the branch from which it came, all the way back to the very beginning of the project.

In Figure 7-1, the dev branch name points to the head commit, Z. If you wanted to rebuild the repository state at Z, then all the commits reachable from Z back to the original commit, A, are needed. The reachable portion of the graph is highlighted with wide lines and covers every commit except (S, G, H, J, K, L).

Each of your branch names, as well as the committed content on each branch, is local to your repository. However, when making your repository available to others, you can publish or elect to make one or any number of branches and the associated commits available, too. Publishing a branch must be done explicitly. Also, if your repository is cloned, your branch names and the development on those branches will all be part of the newly cloned repository copy.

Creating Branches

A new branch is based upon an existing commit within the repository. It is entirely up to you to determine and specify which commit to use as the start of the new branch. Git supports an arbitrarily complex branching structure, including branching branches and forking multiple branches from the same commit.

Once you have identified the commit from which a branch should start, simply use the git branch command. Thus, to create a new branch off the HEAD of your current branch for the purposes of fixing Problem Report #1138, you might use:

$ git branch prs/pr-1138

The basic form of the command is

git branch branch [starting-commit]

git branch branch [default-last-commit or HEAD]

$ git branch prs/pr-1138 rel-2.3

$ git branch prs/pr-1138 db7de5feebef8bcd18c5356cb47c337236b50c13 

When no starting-commit is specified, the default is the revision committed most recently on the current branch. In other words, the default is to start a new branch at the point where you’re working right now. Note that the git branch command merely introduces the name of a branch into the repository. It does not change your working directory to use the new branch. No working directory files change, no implicit branch context changes, and no new commits are made. The command simply creates a named branch at the given commit. You can’t actually start work on the branch until you switch to it,

Sometimes you want to specify a different commit as the start of a branch. For instance, suppose that your project creates a new branch for each reported bug and you hear about a bug in a certain release. It may be convenient to use the starting-commit parameter as an alternative to switching your working directory to the branch that represents the release. Normally, your project establishes conventions that let you specify a starting commit with certainty. For instance, to make a bug fix on the Version 2.3 release of your software, you might specify a branch named rel-2.3 as the starting commit

Listing Branch Names

The git branch command lists branch names found in the repository. 

$ git branch
  bug/pr-1
  dev
* master

The branch currently checked out into your working tree is identified by the asterisk. This example also shows two other branches, bug/pr-1 and dev.  Without additional parameters, only topic branches in the repository are listed. there may be additional remote tracking branches in your repository. You can list those with the -r option. You can list both topic and remote branches with -a.


ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/linux (master)
$ git branch -r
  origin/HEAD -> origin/master
  origin/master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/linux (master)
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  
Viewing Branches

The git show-branch command provides more detailed output than git branch, listing the commits that contribute to one or more branches in roughly reverse chronological order. As with git branch, no options list the topic branches, -r shows remote tracking branches, and -a shows all branches.  

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/linux (master)
$ git show-branch -a
* [master] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
 ! [origin/HEAD] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
  ! [origin/master] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
---
--- [master] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/linux (master)
$ git show-branch -r
! [origin/HEAD] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
 ! [origin/master] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
--
-- [origin/HEAD] Merge tag 'mips-fixes_6.18_2' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux

The git show-branch output is broken down into two sections separated by a line of dashes. The section above the separator lists the names of branches enclosed in square brackets, one per line. Each branch name is associated with a single column of output, identified by either an exclamation mark or—if it is also the current branch—an asterisk.

The lower section of output is a matrix stating which commits are present in each branch. Again, each commit is listed with the first log message line from that commit. A commit is present in a branch if there a plus (+), an asterisk (*), or a minus (-) in that branch’s column. The plus sign indicates the commit is in a branch; the asterisk just highlights the commit as being present on the active branch. The minus sign denotes a merge commit.

For example, both of the following commits are identified by asterisks and are present in the dev branch:

* [dev] Improve the new development
* [dev^] Start some new development.

These two commits are not present in any other branch. They are listed in reverse chronological order: The most recent commit is at the top and the oldest commit at the bottom. Enclosed within square brackets on each commit line, Git also shows you a name for that commit. As already mentioned, Git assigns the branch name to the most recent commit. Previous commits have the same name with trailing caret (^) characters. master as the name for the most recent commit and master^ as the
name for the penultimate commit. Similarly, dev and dev^ are the two most recent commits on the branch dev.

Although the commits within a branch are ordered, branches themselves are listed in an arbitrary order. This is because all branches have equal status; there is no rule stating that one branch is more important than another. If the same commit is present in multiple branches, then it will have a plus sign or an asterisk indicator for each branch. Thus, the last commit shown in the previous output is present in all three branches:

+*+ [master] Added Bob's fixes.

The first plus sign means that the commit is in bug/pr-1, the asterisk means the same commit is in the active branch dev, and the final plus sign means the commit is also in the master branch.

When invoked, git show-branch traverses through all the commits on all branches being shown, stopping the listing on the most recent common commit present on all of them. In this case, Git listed four commits before it found one common to all three branches (Added Bob's fixes.), at which point it stopped.

Stopping at the first common commit is the default heuristic for reasonable behavior. It is presumed that reaching such a common point yields sufficient context to understand how the branches relate to each other. If for some reason you actually want more commit history, use the --more=num option, specifying the number of additional commits you want to see going back in time along the common branch.

If you wanted to see the commit history for just the bug/pr-1 and bug/pr-2 branches, you could use

$ git show-branch bug/pr-1 bug/pr-2

The git show-branch command accepts a set of branch names as parameters, allowing you to limit the history shown to those branches.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch br2_master
[br2_master] add br2 file and edit master file in br2 branch

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch br2_master br1_master
! [br2_master] add br2 file and edit master file in br2 branch
 ! [br1_master] add br1 file and edit master file in br1 branch
--
+  [br2_master] add br2 file and edit master file in br2 branch
 + [br1_master] add br1 file and edit master file in br1 branch
++ [br2_master^] add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)   ## user default branch master HEAD commit
$ git show-branch
! [br1_master] add br1 file and edit master file in br1 branch
 ! [br2_master] add br2 file and edit master file in br2 branch
  * [master] Merge branch 'br2_master'
---
  - [master] Merge branch 'br2_master'
 +* [br2_master] add br2 file and edit master file in br2 branch
+ * [br1_master] add br1 file and edit master file in br1 branch
++* [br2_master^] add master.txt

Although that might be fine for a few branches, if there were many such branches, then naming them all would be quite tedious. Fortunately, Git allows wildcard matching of branch names as well. The same results can be achieved using the simpler bug/* branch wildcard name

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch br*

Checking out Branches

As mentioned earlier in this chapter, your working directory can reflect only one branch at a time. To start working on a different branch, issue the git checkout command. Given a branch name, git checkout makes the branch the new, current working branch. It changes your working tree file and directory structure to match the state of the given branch. However, as you’ll see, Git builds in safeguards to keep you from losing data you haven’t yet committed.

In addition, git checkout gives you access to all states of the repository going back from the tip of the branch to the beginning of the project. This is because, as you may recall from Chapter 6, each commit captures a snapshot of the complete repository state at a given moment in time.

$ git checkout bug/pr-1

The files and directory structure of your working tree have been updated to reflect the state and contents of the new branch, bug/pr-1. However, in order to see that the files your working directory have changed to match the state at the tip of that branch, you must use a regular Unix command such as ls.

Selecting a new current branch might have dramatic effects on your working tree files and directory structure. Naturally, the extent of that change depends on the differences between your current branch and the new, target branch that you would like to check out. The effects of changing branches are:

• Files and directories present in the branch being checked out but not in the current branch are checked out of the object store and placed into your working tree.
• Files and directories present in your current branch but absent in the branch being checked out will be removed from your working tree.
• Files common to both branches are modified to reflect the content present in the checked out branch.

Don’t be alarmed if it looks like the checkout appears to happen almost instantaneously. A common newbie mistake is to think that the checkout didn’t work because it returned instantly after supposedly making huge changes. This is one of the features of Git that truly and strongly differentiates it from many other VCSs. Git is good at determining the minimum set of files and directories that actually need to change during a checkout.

Checking out When You Have Uncommitted Changes

Git precludes the accidental removal or modification of data in your local working tree without your explicit request. Files and directories in your working directory that are not being tracked are always left alone; Git won’t remove or modify them. However, if you have local modifications to a file that are different from changes that are present on the new branch, Git issues an error message such as the following and refuses to check out the target branch:

In this case, a message warns that something has caused Git to stop the checkout request. But what? You can find out by inspecting the contents of the file NewStuff, as it is locally modified in the current working directory

$ git branch
  bug/pr-1
  bug/pr-2
  dev
* master

$ git checkout dev
error: Your local changes to the following files would be overwritten by checkout:
    NewStuff
Please, commit your changes or stash them before you can switch branches.
Aborting

In this case, a message warns that something has caused Git to stop the checkout request, as the NewStuff file is updated in working directory. You can find out by inspecting the contents of the file NewStuff, as it is locally modified in the current working directory, and the target dev branch:

$ cat NewStuff
Something
Something else

$ git diff NewStuff        ## this is from the current active branch in this case dev
diff --git a/NewStuff b/NewStuff
index 0f2416e..5e79566 100644
--- a/NewStuff
+++ b/NewStuff
@@ -1 +1,2 @@
Something
+Something else

$ git show dev:NewStuff    ## show the contents of the file in the dev branch
Something
A Change

If Git brashly honored the request to check out the dev branch, your local modifications to NewStuff in your working directory would be overwritten by the version from dev. By default, Git detects this potential loss and prevents it from happening.

If you really don’t care about losing changes in your working directory and are willing to throw them away, you can force Git to perform the checkout by using the -f option. You could just issue git commit at this point to commit your change into your current branch (master). But suppose you want the change to be made in the new dev branch instead. You seem to be stuck: You can’t put your change into the dev branch until you check it out, and Git won’t let you check it out because your change is present. One approach uses the stash which is explained later.

Merging Changes into a Different Branch

In the previous section, the current state of your working directory conflicted with that of the branch you wanted to switch to. What’s needed is a merge: The changes in your working directory must be merged with the files being checked out. If possible or if specifically requested with the -m option, Git attempts to carry your local change into the new working directory by performing a merge operation between your local modifications and the target branch.

$ git checkout -m dev
M NewStuff
Switched to branch "dev"

Here, Git has modified the file NewStuff and checked out the dev branch successfully. This merge operation occurs entirely in your working directory. It does not introduce a merge commit on any branch. You must be careful in these scenarios, however. Although it may look like the merge was performed cleanly and all is well, Git has simply modified the file and left the merge conflict indicators within it. You must still resolve any conflicts that are present

$ cat NewStuff
Something
<<<<<<< dev:NewStuff
A Change
=======
Something else
>>>>>>> local:NewStuff

$ git show bug/pr-1:NewStuff     ## print contents for the NewStuff file from the branch bug/pr-1

Creating and Checking out a New Branch

Another fairly common scenario happens when you want to both create a new branch and simultaneously switch to it as well. Git provides a shortcut for this with the -b newbranch option. Let’s start with the same setup as the previous example, except now you must start a new branch instead of checking changes into an existing branch. In other words, you are in the master branch, editing files, and suddenly realize that you would like all of the changes to be committed on an entirely new branch named bug/pr-3.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ git switch master
M       master.txt
Switched to branch 'master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git branch
  br1_master
  br2_master
* master

Unless some problem prevents a checkout command from completing, the command: 
$ git checkout -b new-branch start-point

is exactly the same as the two-command sequence:

$ git branch new-branch start-point
$ git checkout new-branch

just use below command

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git checkout -b br3_master
Switched to a new branch 'br3_master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br3_master)   ## new branch br3_master is created and switched to 
$ git branch
  br1_master
  br2_master
* br3_master
  master

Detached HEAD Branches

Normally, it’s advisable to check out only the tip of a branch by naming the branch directly. Thus, by default, git checkout changes to the tip of a desired branch. However, you can check out any commit. In such an instance, Git creates a sort of anonymous branch for you called a detached HEAD. Git creates a detached HEAD when you:

• Check out a commit that is not the head of a branch.
• Check out a tracking branch. You might do this to explore changes recently brought into your repository from a remote repository.
• Check out the commit referenced by a tag. You might do this to put together a release based on tagged versions of files.
• Start a git bisect operation.
• Use the git submodule update command.

## download the source code of git project itself its a opensource code

https://github.com/git/git.git

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo
$ git clone --recursive https://github.com/git/git.git
Cloning into 'git'...
remote: Enumerating objects: 401563, done.
remote: Counting objects: 100% (395/395), done.
remote: Compressing objects: 100% (99/99), done.
remote: Total 401563 (delta 335), reused 296 (delta 296), pack-reused 401168 (from 2)
Receiving objects: 100% (401563/401563), 279.67 MiB | 18.92 MiB/s, done.
Resolving deltas: 100% (303582/303582), done.
Updating files: 100% (4691/4691), done.
Submodule 'sha1collisiondetection' (https://github.com/cr-marcstevens/sha1collisiondetection.git) registered for path 'sha1collisiondetection'
Cloning into 'H:/git_repo/git/sha1collisiondetection'...
remote: Enumerating objects: 896, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 896 (delta 1), reused 2 (delta 1), pack-reused 891 (from 2)
Receiving objects: 100% (896/896), 618.86 KiB | 1.52 MiB/s, done.
Resolving deltas: 100% (568/568), done.
Submodule path 'sha1collisiondetection': checked out '855827c583bc30645ba427885caa40c5b81764d2'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)    ## check which brach you are in now that is master
$ git branch
* master

Check commits with log command

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)
$ git log -Sinclude --pretty=oneline --abbrev-commit
ac65c70663 odb: handle recreation of quarantine directories
2816b748e5 odb: handle changing a repository's commondir
9aaba57993 odb: adopt logic to close object databases
831e02340b path: move `enter_repo()` into "setup.c"
6971934d9b doc: define unambiguous type mappings across C and Rust
ffffb987fc blame: make diff algorithm configurable
878fef8ebf t/unit-tests: add UTF-8 width tests for CJK chars
ad892a61d6 l10n: zh_CN: updated translation for 2.52
1480c3907b l10n: uk: add 2.52 translation
8b26798b42 l10n: tr: Update Turkish translations
<many more commits here>
9fd38038b9 t1006: update 'run_tests' to test generic object specifiers
5bb4298acf builtin/maintenance: split into foreground and background tasks
bf5ce434db l10n: Add full Irish translation (ga.po)
7a1903ad46 (tag: v2.43.7) Git 2.43.7                                      ## Notice a commit with tag for major version 2.43.7
09fb155f11 diff --no-index: support limiting by pathspec
187ce0222f configure.ac: upgrade to a compilation check for sysinfo
7649d316ce docs: replace git_config to repo_config
4f7f571204 pack-objects: enable --path-walk via config
70664d2865 pack-objects: add --path-walk option
f2ed511a2f t/helper: add zlib test-tool

try to create a branch out of v2.43.7 which created a detached head branch as shown below

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)
$ git checkout v2.43.7
Updating files: 100% (4290/4290), done.
Note: switching to 'v2.43.7'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 7a1903ad46 Git 2.43.7

Try must older version 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git ((v2.43.7))
$ git checkout v1.6.0
warning: unable to rmdir 'sha1collisiondetection': Directory not empty
Previous HEAD position was 7a1903ad46 Git 2.43.7
HEAD is now at ea02eef096 GIT 1.6.0

Check with git branch command see there is brach for detached head for V1.6.0

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git ((v1.6.0))
$ git branch
* (HEAD detached at v1.6.0)
  master

If, after finding yourself on a detached HEAD, you later decide that you need to make new commits at that point and keep them, you must first create a new branch: This will give you a new, proper branch based on the commit where the detached HEAD was. You can then continue with normal development. Essentially, you named the branch that was previously anonymous.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git ((v1.6.0))
$ git checkout -b my_br_v1.6.0
Switched to a new branch 'my_br_v1.6.0'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ git branch
  master
* my_br_v1.6.0

On the other hand, if you are finished with the detached HEAD and want to simply abandon that state, you can convert to a named branch by simply entering git checkout branch.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ git checkout master
Updating files: 100% (5167/5167), done.
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

Deleting Branches

The command git branch -d branch removes the named branch from a repository. Git prevents you from removing the current branch:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)
$ git checkout my_br_v1.6.0
warning: unable to rmdir 'sha1collisiondetection': Directory not empty
Switched to branch 'my_br_v1.6.0'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ git branch
  master
* my_br_v1.6.0

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)     ## prevent delete of working branch
$ git branch -d my_br_v1.6.0
error: cannot delete branch 'my_br_v1.6.0' used by worktree at 'H:/git_repo/git'

Removing the current branch would leave Git unable to determine what the resulting working directory tree should look like. Instead, you must always name a noncurrent branch.

But there is another subtle issue. Git won’t allow you to delete a branch that contains commits that are not also present on the current branch. That is, Git prevents you from accidentally removing development in commits that will be lost if the branch were to be deleted.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ echo "Siva testing branch delete" > sivanesan.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ ll siva*
-rw-r--r-- 1 ADMIN 197121 27 Dec  9 18:22 sivanesan.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ git add sivanesan.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ git commit -m "add sivanesan.txt"
[my_br_v1.6.0 50ac8d2be4] add sivanesan.txt
 1 file changed, 1 insertion(+)
 create mode 100644 sivanesan.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (my_br_v1.6.0)
$ git checkout master
Updating files: 100% (5168/5168), done.
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)      ## Erros saying there are unmerged file sivanesan.txt in the my_br_v1.6.0 branch
$  git branch -d my_br_v1.6.0
error: the branch 'my_br_v1.6.0' is not fully merged
hint: If you are sure you want to delete it, run 'git branch -D my_br_v1.6.0'
hint: Disable this message with "git config advice.forceDeleteBranch false"

-D option will force delete the my_br_v1.6.0 branch

check the details with git show-branch command 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)
$ git show-branch
* [master] The sixth batch
 ! [my_br_v1.6.0] add sivanesan.txt
--
 + [my_br_v1.6.0] add sivanesan.txt
*  [master] The sixth batch
*  [master^^2] config: fix suggestion for failed set of multi-valued option
*  [master~2^2] config: fix short help of unset flags
*  [master~3^2] odb: handle recreation of quarantine directories

Git is not mandating that all branches be merged into the master branch before they can be deleted. Remember, a branch is simply a name or pointer to a commit that has actual content. Instead, Git is keeping you from accidentally losing content from the branch to be deleted that is not merged into your current branch.

When you merge sivanesan.txt gets added with master you can then delete my_br_v1.6.0

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)
$ git merge my_br_v1.6.0
Merge made by the 'ort' strategy.
 sivanesan.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 sivanesan.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/git (master)
$ git branch -d my_br_v1.6.0
Deleted branch my_br_v1.6.0 (was 50ac8d2be4).

Git does not maintain any form of historical record of branch names being created, moved, manipulated, merged, or deleted. Once a branch name has been removed, it is gone.

The commit history on that branch, however, is a separate question. Git will eventually prune away commits that are no longer referenced and reachable from some named ref such as a branch or tag name. If you want to keep those commits, you must either merge them into a different branch, make a branch for them, or point a tag reference to them. Otherwise, without a reference to them, commits and blobs are unreachable and will eventually be collected as garbage by the git gc tool.

After accidentally removing a branch or other ref, you can recover it by using the git reflog command. Other commands such as git fsck and configuration options such as gc.reflogExpire and gc.pruneExpire can also help recover lost commits, files, and branch heads.

Diffs - Chapter 8

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ mkdir L08_diff

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ cd L08_diff/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L08_diff/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ cat initial.txt
Now is the time
For all good men
To come to the aid
Of their country.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ cat rewrite.txt
Today is the time
For all good men
And women
To come to the aid
Of their country.

use normal linux diff command The -u option produces a unified diff, a standardized format used widely to share modifications

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ diff -u initial.txt rewrite.txt
--- initial.txt 2025-12-09 18:47:32.857918000 +0530
+++ rewrite.txt 2025-12-09 18:48:11.582917700 +0530
@@ -1,4 +1,5 @@
-Now is the time
+Today is the time
 For all good men
+And women
 To come to the aid
 Of their country.
 
Let’s look at the diff in detail. In the header, the original file is denoted by --- and the new file by +++. The @@ line provides line number context for both file versions. A line prefixed with a minus sign (–) must be removed from the original file to produce the new file. Conversely, a line with a leading plus sign (+) must be added to the original file to produce the new file. A line that begins with a space is the same in both files and is provided by the -u option as context. In addition, diff can be extended to show differences among multiple files and entire directory hierarchies.

The command diff -r traverses each hierarchy in tandem, twins files by pathname (say, original/src/main.c and new/src/main.c), and summarizes the differences between each pair. Using diff -r -u produces a set of unified diffs comparing two hierarchies.

Git has its own diff facility and can likewise produce a digest of differences. The command git diff can compare files much akin to Unix’s diff command. Moreover, like diff -r, Git can traverse two tree objects and generate a representation of the variances. But git diff also has its own nuances and powerful features tailored to the particular needs of Git users.

Technically, a tree object represents only one directory level in the repository. It contains information on the directory’s immediate files and immediate subdirectories, but it does not catalog the complete contents of all subdirectories. However, because a tree object references the tree objects for each subdirectory, the tree object at the root of the project effectively represents the entire project at a moment in time. Hence, we can paraphrase and say git diff traverses “two” trees.

Forms of the git diff Command

If you pick two different root-level tree objects for comparison, git diff yields all deviations between the two project states. There are three basic sources for tree or treelike objects to use with git diff:

• Any tree object anywhere within the entire commit graph
• Your working directory
• The index

Typically, the trees compared in a git diff command are named via commits, branch names, or tags, but any commit name suffices. Also, both the file and directory hierarchy of your working directory, as well as the complete hierarchy of files staged in the index, can be treated as trees. The git diff command can perform four fundamental comparisons using various combinations of those three sources.

git diff : 
git diff shows the difference between your working directory and the index. It exposes what is dirty in your working directory and is thus a candidate to stage for your next commit.

git diff commit : 
This form summarizes the differences between your working directory and the given commit. Common variants of this command name HEAD or a particular branch name as the commit.

git diff --cached commit : 
This command shows the differences between the staged changes in the index and the given commit. A common commit for the comparison—and the default if no commit is specified—is HEAD. With HEAD, this command shows you how your next commit will alter the current branch. If the option --cached doesn’t make sense to you, perhaps the synonym --staged will.

git diff commit1 commit2 :
If you specify two arbitrary commits, the command displays the differences between the two. This command ignores the index and working directory, and it is the workhorse for arbitrary comparisons between two trees that are already in your object store.

The number of parameters on the command line determines what fundamental form is used and what is compared. You can compare any two commits or trees. What’s
being compared need not have a direct or even an indirect parent–child relationship. If you don’t supply a tree object or two, then git diff compares implied sources, such as your index or working directory.

git diff example
~~~~~~~~~~~~~~~~~
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ echo "only in index" > fileinindex.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ git add fileinindex.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## Check if the file is in index
$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   fileinindex.txt

## Edit the file in working directory add a new line

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ echo "\nnew line in fileinindex" >> fileinindex.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ git diff
diff --git a/fileinindex.txt b/fileinindex.txt
index d184508..57d21e3 100644
--- a/fileinindex.txt
+++ b/fileinindex.txt
@@ -1 +1,2 @@
 only in index
+\nnew line in fileinindex

git diff commit example
~~~~~~~~~~~~~~~~~
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## commit the indexed file with one line
$ git commit -m "commit first line only"
[master 951f0d1] commit first line only
 1 file changed, 1 insertion(+), 1 deletion(-)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ git show master:fileinindex.txt
only in index

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ cat fileinindex.txt
only in index
\nnew line in fileinindex

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## commit ID 951f0d1 and work directory has one line difference
$ git diff 951f0d1
diff --git a/fileinindex.txt b/fileinindex.txt
index d184508..57d21e3 100644
--- a/fileinindex.txt
+++ b/fileinindex.txt
@@ -1 +1,2 @@
 only in index
+\nnew line in fileinindex

git diff commit example
~~~~~~~~~~~~~~~~~
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## add one more line in working directory
$ echo "this line added before staging" >> fileinindex.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## check diff - nothing shown because the file is not yet indexed or staged

$ git diff --staged 951f0d1
$ git diff --staged 
$ git diff --cached 951f0d1
$ git diff --cached

all above produce same result as 951f0d1 and HEAD are same commits as of now

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ git diff --staged 951f0d1
diff --git a/fileinindex.txt b/fileinindex.txt
index d184508..2b1ad8b 100644
--- a/fileinindex.txt
+++ b/fileinindex.txt
@@ -1 +1,3 @@
 only in index
+\nnew line in fileinindex
+this line added before staging              ## this is additional line in staged file but not in old commit

git diff commit commit example
~~~~~~~~~~~~~~~~~

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ git commit -m "this is second commit with 3 lines"
[master 9da68f2] this is second commit with 3 lines
 1 file changed, 2 insertions(+)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## diff of first commit vs second commit this is same as $ git diff HEAD^ HEAD PrevHEAD vs HEAD
$ git diff 951f0d1 9da68f2
diff --git a/fileinindex.txt b/fileinindex.txt
index d184508..2b1ad8b 100644
--- a/fileinindex.txt
+++ b/fileinindex.txt
@@ -1 +1,3 @@
 only in index
+\nnew line in fileinindex
+this line added before staging

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)   ## diff of second commit vs first commit
$ git diff 9da68f2 951f0d1
diff --git a/fileinindex.txt b/fileinindex.txt
index 2b1ad8b..d184508 100644
--- a/fileinindex.txt
+++ b/fileinindex.txt
@@ -1,3 +1 @@
 only in index
-\nnew line in fileinindex
-this line added before staging

Its good technique to use git diff without arguments is a good technique for verifying the readiness of your next commit. As long as that command emits output, you have edits or changes in your working directory that are not yet staged.

git commit captures all changes in your index into a new commit. A commit captures only your staged changes.

In addition to the four basic forms of git diff, there are myriad options as well. Here are a few of the more useful ones.

-M : The -M option detects renames and generates a simplified output that simply records the file rename rather than the complete removal and subsequent addition of the source file
-w or --ignore-all-space : Both -w and --ignore-all-space compare lines without considering changes in whitespace as significant
--stat : The --stat option adds statistics about the difference between any two tree states. It reports in a compact syntax how many lines changed, how many were added, and how many were elided.
--color : The --color option colorizes the output; a unique color represents each of the different types of changes present in the diff.


ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L08_diff (master)
$ git diff --stat 9da68f2 951f0d1
 fileinindex.txt | 2 --
 1 file changed, 2 deletions(-)

Merges : chapter 9 

Git is a distributed version control system (DVCS). It allows, for example, a developer in Japan and another in New Jersey to make and record changes independently, and it permits the two developers to combine their changes at any time, all without a central repository.

A merge unifies two or more commit history branches. Most often, a merge unites just two branches, although Git supports a merge of three, four, or more branches at the same time. In Git, a merge must occur within a single repository—that is, all the branches to be merged must be present in the same repository. How the branches come to be in the repository is not important. Also Git provides mechanisms for referring to other repositories and for bringing remote branches into your current working repository.

When modifications in one branch do not conflict with modifications found in another branch, Git computes a merge result and creates a new commit that represents the new, unified state. But when branches conflict, which occurs whenever changes compete to alter the same line of the same file, Git does not resolve the dispute. Instead, Git marks such contentious changes as “unmerged” in the index and leaves reconciliation up to you, the developer. When Git cannot merge automatically, it’s also up to you to make the final commit once all conflicts are resolved.

The git merge operation is context sensitive. Your current branch is always the target branch, and the other branch or branches are merged into the current branch. To merge other_branch into branch, you should check out the target branch and merge the other branches into it,

$ git checkout branch
$ git merge other_branch

During a normal merge, Git creates new versions of files and places them in your working directory when  it is finished. Furthermore, Git also uses the index to store temporary and intermediate versions of files during the operation. If you have modified files in your working directory or if you’ve modified the index via git add or git rm, then your repository has a dirty working directory or index. If you start a merge in a dirty state, Git may be unable to combine the changes from all the branches and from those in your working directory or index in one pass. as a general rule, your Git life will be much easier if you start each merge with a clean working directory and index.

Merging Two Branches

For the simplest scenario, let’s set up a repository with a single file, create two branches, and then merge the pair of branches together again.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ mkdir L09_merge

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ cd L09_merge/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_merge
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L09_merge/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_merge (master)
$ cat > file1.txt
Line 1 a
Line 2 B
Line 3 c
^d

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git add file1.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git commit -m "Initial 3 line file"
[master (root-commit) 65a118b] Initial 3 line file
 1 file changed, 3 insertions(+)
 create mode 100644 file1.txt
 
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_merge (master)   ## Add aonther file and commit
$ cat > otherfile.txt
just another file with no conflict

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git add otherfile.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git commit -m "add otherfile to no confilict scenario"
[master 455f3cd] add otherfile to no confilict scenario
 1 file changed, 1 insertion(+)
 create mode 100644 otherfile.txt

So far, the repository has one branch with two commits, where each commit introduced a new file. Next, let’s change to a different branch and modify the first file.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)     ## create branch alternate from first commit for master (master^)
$ git checkout -b alternate master^
Switched to a new branch 'alternate'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git branch
* alternate
  master

Here, the alternate branch is initially forked from the master^ commit, one commit behind the current head.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)  ## The alternate branch is forked from the master^, one commit behind the current head.
$ git show-branch
* [alternate] Initial 3 line file
 ! [master] add otherfile to no confilict scenario
--
 + [master] add otherfile to no confilict scenario
*+ [alternate] Initial 3 line file

Here, the alternate branch is initially forked from the master^ commit, one commit behind the current head.

Make a trivial change to the file so you have something to merge, and then commit it. Remember, it’s best to commit outstanding changes and start a merge with a clean working directory.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ cat >> file1.txt
Alt line 4 D
^d

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ cat file1.txt
Line 1 a
Line 2 B
Line 3 c
Alt line 4 D

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git add file1.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git commit -m "4th line add in alt branch"
[alternate 15f4fa5] 4th line add in alt branch
 1 file changed, 1 insertion(+)

Now there are two branches and each has different development work. A file has been added to the master branch, and a modification has been made to alternate
the branch. Because the two changes do not affect the same parts of a common file, a merge should proceed smoothly and without incident.

The git merge operation is context sensitive. Your current branch is always the target branch, and the other branch or branches are merged into the current branch. In this case, the alternate branch should be merged into the master branch, so the latter must be checked out before you continue:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git checkout master
Switched to branch 'master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git status
On branch master
nothing to commit, working tree clean

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master|MERGING)
$ git merge alternate -m "Merge commit alternate branch with master"
[master 4496139] Merge commit alternate branch with master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git log --graph --pretty=oneline --abbrev-commit
*   4496139 (HEAD -> master) Merge commit alternate branch with master
|\
| * 15f4fa5 (alternate) 4th line add in alt branch
* | 455f3cd add otherfile to no confilict scenario
|/
* 65a118b Initial 3 line file

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git log --graph --abbrev-commit
*   commit 4496139 (HEAD -> master)
|\  Merge: 455f3cd 15f4fa5
| | Author: Sivanesan G <nesan.committer@gmail.com>
| | Date:   Thu Dec 11 15:29:15 2025 +0530
| |
| |     Merge commit alternate branch with master
| |
| * commit 15f4fa5 (alternate)
| | Author: Sivanesan G <nesan.committer@gmail.com>
| | Date:   Thu Dec 11 15:23:51 2025 +0530
| |
| |     4th line add in alt branch
| |
* | commit 455f3cd
|/  Author: Sivanesan G <nesan.committer@gmail.com>
|   Date:   Thu Dec 11 15:15:23 2025 +0530
|
|       add otherfile to no confilict scenario
|
* commit 65a118b
  Author: Sivanesan G <nesan.committer@gmail.com>
  Date:   Thu Dec 11 15:14:15 2025 +0530

      Initial 3 line file
	  
That is conceptually the commit graph, with the most recent commits at the top. The two branches have split at the initial commit, 455f3cd; each branch shows one commit each (455f3cd and 15f4fa5); and the two branches merge again at commit 4496139. Using git log --graph is an excellent alternative to graphical tools such as gitk.

Technically, Git performs each merge symmetrically to produce one identical, combined commit that is added to your current branch. The other branch is not affected by the merge. Because the merge commit is added only to your current branch, you can say, “I merged some other branch into this one.”

A Merge with a Conflict

The merge operation is inherently problematic because it necessarily brings together potentially varying and conflicting changes from different lines of development. The changes on one branch may be similar to or radically different from the changes on a different branch. Modifications may alter the same files or a disjoint set of files. Git can handle all these varied possibilities, but often it requires guidance from you to resolve conflicts.

On the master branch, create a new version of file with a few additional lines in it and then commit the changes:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ cat >> file1.txt
Alt line 5 EEE
^d

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git commit -a -m "Add line 5"
[master 16df0e4] Add line 5
 1 file changed, 1 insertion(+)

Now, on the alternate branch, modify the same file differently. Whereas you made new commits to the master branch, the alternate branch has not progressed yet.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git checkout alternate
Switched to branch 'alternate'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git show-branch
* [alternate] 4th line add in alt branch
 ! [master] Add line 5
--
 + [master] Add line 5
*+ [alternate] 4th line add in alt branch

Notice the file1.txt in working folder is overwritten and line 5 is missing in this file 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ cat file1.txt
Line 1 a
Line 2 B
Line 3 c
Alt line 4 D

## Edit the file and add new lines 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ cat >> file1.txt
Alt line 5 EEE
Alt line 6 - conflict
^d 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git commit -a -m "Add alternate line 5 and 6 for conflict"
[alternate d52ab93] Add alternate line 5 and 6 for conflict
 1 file changed, 2 insertions(+)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git show-branch
* [alternate] Add alternate line 5 and 6 for conflict
 ! [master] Add line 5
--
*  [alternate] Add alternate line 5 and 6 for conflict
 + [master] Add line 5
*+ [alternate^] 4th line add in alt branch

To continue, check out the master branch and try to perform the merge:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (alternate)
$ git checkout master
Switched to branch 'master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git merge alternate -m "this is conflict merge"
Auto-merging file1.txt
CONFLICT (content): Merge conflict in file1.txt
Automatic merge failed; fix conflicts and then commit the result.

Merge failed now.. we need to fix this. When a merge conflict like this occurs, you should almost invariably investigate the extent of the conflict using the git diff command. Here, the single file named file has a conflict in its content:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master|MERGING)
$ git diff
diff --cc file1.txt
index 29dd895,493eaa1..0000000
--- a/file1.txt
+++ b/file1.txt
@@@ -3,3 -3,4 +3,7 @@@ Line 2
  Line 3 c
  Alt line 4 D
  Alt line 5 EEE
++<<<<<<< HEAD
++=======
+ Alt line 6 - conflict
++>>>>>>> alternate

The git diff command shows the differences between the file in your working directory and the index. In the traditional diff command output style, the changed content is presented between <<<<<<< and =======, with an alternate between ======= and >>>>>>>. However, additional plus and minus signs are used in the combined diff format to indicate changes from multiple sources relative to the final resulting version.

After mannually doing conflict resolution, you should git add the file to the index and stage it for the merge commit: After you have resolved conflicts and staged final versions of each file in the index using git add, it is finally time to commit the merge using git commit.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master|MERGING)
$ git add file1.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master|MERGING)
$ git commit -m "to merge commit after fixing conflicts in the file1.txt"
[master 625c4ef] to merge commit after fixing conflicts in the file1.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ git log --graph --pretty=oneline --abbrev-commit
*   625c4ef (HEAD -> master) to merge commit after fixing conflicts in the file1.txt
|\
| * d52ab93 (alternate) Add alternate line 5 and 6 for conflict
* | 16df0e4 Add line 5
* | 4496139 Merge commit alternate branch with master
|\|
| * 15f4fa5 4th line add in alt branch
* | 455f3cd add otherfile to no confilict scenario
|/
* 65a118b Initial 3 line file

check contents for the file1.txt... it is because manual fix was not done. merge alters the file contents when there is confict its your responsibitity to edit and correct it before moving forward with commit. If not done the code will stay corrupt only as shown below.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L09_branch (master)
$ cat file1.txt
Line 1 a
Line 2 B
Line 3 c
Alt line 4 D
Alt line 5 EEE
<<<<<<< HEAD
=======
Alt line 6 - conflict
>>>>>>> alternate

Working with Merge Conflicts

Let’s create another scenario with a merge conflict to explore the tools Git provides to help resolve disparities. Starting with a common hello with just the contents “hello,” let’s create two different branches with two different variants of the file.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L10_merge_tools/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ echo "Hello" > hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ git add hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ git commit -m "first commit hello"
[master (root-commit) 1d38161] first commit hello.txt
 1 file changed, 1 insertion(+)
 create mode 100644 hello.txt

checkout and create new branch alt 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ git checkout -b alt
Switched to a new branch 'alt'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ cat hello.txt
Hello

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ echo world >> hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ echo 'Yay!' >> hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ cat hello.txt
Hello
world
Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ git commit -a -m "One world"
[alt daffef4] One world
 1 file changed, 2 insertions(+)

One branch says world, whereas the other says worlds, a deliberate difference. Checkout master and try to merge alt branch into master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ cat hello.txt
Hello
world
Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (alt)
$ git checkout master
Switched to branch 'master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)   ## file restored as in the master
$ cat hello.txt
Hello

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ echo worlds >> hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ echo 'Yay!' >> hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ cat hello.txt
Hello
worlds
Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ git commit -a -m "Worlds commit"
[master 7b04bd1] Worlds commit
 1 file changed, 2 insertions(+)

try to merge the alt branch into master, a conflict arises.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ git merge alt -m "yeah a conflict"
Auto-merging hello.txt
CONFLICT (content): Merge conflict in hello.txt
Automatic merge failed; fix conflicts and then commit the result.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)   ## contents of hello.txt has merge differences
$ cat hello.txt
Hello
<<<<<<< HEAD                    ## HEAD has worlds
worlds
=======
world
>>>>>>> alt                     ## alt has world
Yay!

Locating Conflicted Files

But what if Git’s helpful directions scrolled off the screen or if there were many files with conflicts? Luckily, Git keeps track of problematic files by marking each one in the index as conflicted, or unmerged.

You can also use either the git status command or the git ls-files -u command to show the set of files that remain unmerged in your working tree.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   hello.txt

no changes added to commit (use "git add" and/or "git commit -a")

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git ls-files -u
100644 e965047ad7c57865823c7d992b1d046ea66edf78 1       hello.txt
100644 a97f48fd9a38a884e9060a3bba9dc72518a8b053 2       hello.txt
100644 2f9ee7e9c4bb26a33c21d54917214e016eb2c905 3       hello.txt

You can use git diff to show what’s not yet merged, but it will show all of the gory details, too!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff
diff --cc hello.txt
index a97f48f,2f9ee7e..0000000
--- a/hello.txt
+++ b/hello.txt
@@@ -1,3 -1,3 +1,7 @@@
  Hello
++<<<<<<< HEAD
 +worlds
++=======
+ world
++>>>>>>> alt
  Yay!
  
Inspecting Conflicts

When a conflict appears, the working directory copy of each conflicted file is enhanced with three-way diff or merge markers. in this case hello.txt is modified as below

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ cat hello.txt
Hello
<<<<<<< HEAD
worlds
=======
world
>>>>>>> alt
Yay!

The merge markers delineate the two possible versions of the conflicting chunk of the file. In the first version, the chunk says “worlds”; in the other version, it says “world.” You could simply choose one phrase or the other, remove the conflict markers, and then run git add and git commit, but let’s explore some of the other features Git offers to help resolve conflicts.
  
The three-way merge marker lines (<<<<<<<<, ========, and >>>>>>>>) are automatically generated, but they’re just meant to be read by you, not (necessarily) a program. You should delete them with your text editor once you resolve the conflict.

git diff with conflicts

Git has a special, merge-specific variant of git diff to display the changes made against both parents simultaneously. In the example, it looks like this:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff
diff --cc hello.txt
index a97f48f,2f9ee7e..0000000
--- a/hello.txt
+++ b/hello.txt
@@@ -1,3 -1,3 +1,7 @@@
  Hello
++<<<<<<< HEAD
 +worlds
++=======
+ world
++>>>>>>> alt
  Yay!
  
What does it all mean? It’s the simple combination of two diffs: one versus the first parent, called HEAD, and one against the second parent, or alt. To make things easier, Git also gives the second parent the special name MERGE_HEAD.

You can compare both the HEAD and MERGE_HEAD versions against the working directory (“merged”) version:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff HEAD
diff --git a/hello.txt b/hello.txt
index a97f48f..95c91ad 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1,3 +1,7 @@
 Hello
+<<<<<<< HEAD
 worlds
+=======
+world
+>>>>>>> alt
 Yay!
 
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff --theirs
* Unmerged path hello.txt
diff --git a/hello.txt b/hello.txt
index 2f9ee7e..95c91ad 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1,3 +1,7 @@
 Hello
+<<<<<<< HEAD
+worlds
+=======
 world
+>>>>>>> alt
 Yay!



ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff MERGE_HEAD
diff --git a/hello.txt b/hello.txt
index 2f9ee7e..95c91ad 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1,3 +1,7 @@
 Hello
+<<<<<<< HEAD
+worlds
+=======
 world
+>>>>>>> alt
 Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff --ours
* Unmerged path hello.txt
diff --git a/hello.txt b/hello.txt
index a97f48f..95c91ad 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1,3 +1,7 @@
 Hello
+<<<<<<< HEAD
 worlds
+=======
+world
+>>>>>>> alt
 Yay!

In newer versions of Git, git diff --ours is a synonym for git diff HEAD, because it shows the differences between “our” version and the merged version. Similarly, git diff MERGE_HEAD can be written as git diff --theirs. You can use git diff --base to see the combined set of changes since the merge base, which would otherwise be rather awkwardly written as:

Running git diff on a conflicted file only shows you the sections that really have a conflict. In a large file with numerous changes scattered throughout, most of those changes don’t have a conflict; either one side of the merge changed a particular section or the other side did.





ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff HEAD MERGE_HEAD
diff --git a/hello.txt b/hello.txt
index a97f48f..2f9ee7e 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1,3 +1,3 @@
 Hello
-worlds
+world
 Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff MERGE_HEAD HEAD
diff --git a/hello.txt b/hello.txt
index 2f9ee7e..a97f48f 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1,3 +1,3 @@
 Hello
-world
+worlds
 Yay!

once you fix the file as below then git diff output is empty

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ cat hello.txt
Hello
world
Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)   ## It doesn’t show worlds was there and it got changed back to world 
$ git diff
diff --cc hello.txt
index a97f48f,2f9ee7e..0000000
--- a/hello.txt
+++ b/hello.txt

git log with conflicts

While you’re in the process of resolving a conflict, you can use some special git log options to help you figure out exactly where the changes came from and why. Try this:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git log --merge --left-right -p
commit < 7b04bd1612ad00ff6ca843326098a3b480d86ffd (HEAD -> master)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Dec 11 19:24:33 2025 +0530

    Worlds commit

diff --git a/hello.txt b/hello.txt
index e965047..a97f48f 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1 +1,3 @@
 Hello
+worlds
+Yay!

commit > ec641497eb6ff95d1ac332c905e15595c0fa4784 (alt)
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Thu Dec 11 19:20:30 2025 +0530

    One world

diff --git a/hello.txt b/hello.txt
index e965047..2f9ee7e 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1 +1,3 @@
 Hello
+world
+Yay!

This command shows all the commits in both parts of the history that affect conflicted files in your merge, along with the actual changes each commit introduced. If you wondered when, why, how, and by whom the line worlds came to be added to the file, you can see exactly which set of changes introduced it.

The options provided to git log are as follows:
• --merge shows only commits related to files that produced a conflict
• --left-right displays < if the commit was from the “left” side of the merge (“our” version, the one you started with), or > if the commit was from the “right” side of the merge (“their” version, the one you’re merging in)
• -p shows the commit message and the patch associated with each commit

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)    ## used only to check changes to hello.txt
$ git log --merge --left-right -p hello.txt

How Git Keeps Track of Conflicts

How exactly does Git keep track of all the information about a conflicted merge? There are several parts:

• .git/MERGE_HEAD contains the SHA1 of the commit you’re merging in. You don’t really have to use the SHA1 yourself; Git knows to look in that file whenever you talk about MERGE_HEAD.
• .git/MERGE_MSG contains the default merge message used when you git commit after resolving the conflicts.
• The Git index contains three copies of each conflicted file: the merge base, “our” version, and “their” version. These three copies are assigned respective stage numbers 1, 2, and 3.
• The conflicted version (merge markers and all) is not stored in the index. Instead, it is stored in a file in your working directory. When you run git diff without any parameters, the comparison is always between what’s in the index with what’s in your working directory.

To see how the index entries are stored, you can use the git ls-files plumbing command as follows:

The -s option to git ls-files shows all the files with all stages. If you want to see only the conflicted files, use the -u option instead.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git ls-files -s
100644 e965047ad7c57865823c7d992b1d046ea66edf78 1       hello.txt
100644 a97f48fd9a38a884e9060a3bba9dc72518a8b053 2       hello.txt
100644 2f9ee7e9c4bb26a33c21d54917214e016eb2c905 3       hello.txt

In other words, the hello file is stored three times, and each has a different hash corresponding to the three different versions. You can look at a specific variant by using git cat-file:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git cat-file -p e965047ad7
Hello

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git cat-file -p a97f48fd9a
Hello
worlds
Yay!

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git cat-file -p 2f9ee7e9c4
Hello
world
Yay!

You can also use some special syntax with git diff to compare different versions of the file. For example, if you want to see what changed between the merge base and the version you’re merging in, you can do this:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff :1:hello.txt :3:hello.txt
diff --git a/hello.txt b/hello.txt
index e965047..2f9ee7e 100644
--- a/hello.txt
+++ b/hello.txt
@@ -1 +1,3 @@
 Hello
+world
+Yay!

Starting with Git version 1.6.1, the git checkout command accepts the --ours or --theirs option as shorthand for simply checking out (a file from) one side or the other of a conflicted merge; your choice resolves the conflict. These two options can only be used during a conflict resolution.

Using the stage numbers to name a version is different from git diff --theirs, which shows the differences between their version and the resulting, merged (or still conflicted) version in your working directory. The merged version is not yet in the index, so it doesn’t even have a number. Because you fully edited and resolved the working copy version in favor of their version, there should be no difference now: check git status also

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git diff --theirs
* Unmerged path hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   hello.txt

no changes added to commit (use "git add" and/or "git commit -a")

Finishing Up a Conflict Resolution

Let’s make one last change to the hello file before declaring it merged: and merging it

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ cat hello.txt
Hello
everyone
Yay!

Now that the file is fully merged and resolved, git add reduces the index to just a single copy of the hello file again:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git ls-files -s
100644 b043e5e0cf35b8aff8ff0f4bfd516b6862fee0d3 0       hello.txt

That lone 0 between the SHA1 and the path name tells you that the stage number for a nonconflicted file is zero.

You must work through all the conflicted files as recorded in the index. You cannot commit as long as there is an unresolved conflict. Therefore, as you fix the conflicts in a file, run git add (or git rm, git update-index, etc.) on the file to clear its conflict status. Be careful not to git add files with lingering conflict markers. Although that will clear the conflict in the index and allow you to commit, your file won’t be correct.

Finally, you can git commit the end result and use git show to see the merge commit:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ cat .git/MERGE_MSG
yeah a conflict

# Conflicts:
#       hello.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master|MERGING)
$ git commit -m "final merge commit"
[master 4499350] final merge commit

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L10_merge_tools (master)
$ git show
commit 449935065158b715cf83bfc4c54f9ed0518c3702 (HEAD -> master)
Merge: 7b04bd1 ec64149
Author: Sivanesan G <nesan.committer@gmail.com>
Date:   Fri Dec 12 07:08:32 2025 +0530

    final merge commit

diff --cc hello.txt
index a97f48f,2f9ee7e..b043e5e
--- a/hello.txt
+++ b/hello.txt
@@@ -1,3 -1,3 +1,3 @@@
  Hello
- worlds
 -world
++everyone
  Yay!

You should notice three interesting things when you look at a merge commit: 

• There is a new, second line in the header that says Merge:. Normally there’s no need to show the parent of a commit in git log or git show, since there is only one parent and it’s typically the one that comes right after it in the log. But merge commits typically have two (and sometimes more) parents, and those parents are important to understanding the merge. Hence, git log and git show always print the SHA1 of each ancestor.

• The automatically generated commit log message helpfully notes the list of files that conflicted. This can be useful later if it turns out a particular problem was caused by your merge. Usually, problems caused by a merge are caused by the files that had to be merged by hand.

• The diff of a merge commit is not a normal diff. It is always in the combined diff or “conflicted merge” format. A successful merge in Git is considered to be no change at all; it is simply the combination of other changes that already appeared in the history. Thus, showing the contents of a merge commit shows only the parts that are different from one of the merged branches, not the entire set of changes.

Aborting or Restarting a Merge

If you start a merge operation but then decide for some reason that you don’t want to complete it, Git provides an easy way to abort the operation. Prior to executing the final git commit on the merge commit, use:

$ git reset --hard HEAD

This command restores both your working directory and the index to the state immediately prior to the git merge command. 

If you want to abort or discard the merge after it has finished (that is, after it’s introduced a new merge commit), use the command:

$ git reset --hard ORIG_HEAD

Prior to beginning the merge operation, Git saves your original branch HEAD in the ORIG_HEAD ref for just this sort of purpose.

You should be very careful here, though. If you did not start the merge with a clean working directory and index, you could get in trouble and lose any uncommitted changes you have in your directory. You can initiate a git merge request with a dirty working directory, but if you execute git reset --hard then your dirty state prior to the merge is not fully restored. Instead, the reset loses your dirty state in the working directory area.

Starting with Git version 1.6.1, you have another choice. If you have botched a conflict resolution and want to return to the original conflict state before trying to resolve it again, you can use the command git checkout -m.

You can always find the merge base between two or more branches by using git merge-base. It is possible for there to be more than one equally valid merge base for a set of branches.

Altering Commits

A commit records the history of your work and keeps your changes sacrosanct, but the commit itself isn’t cast in stone. Git provides several tools and commands specifically designed to help you modify and improve the commit history cataloged within your repository. There are many valid reasons why you might modify or rework a commit or your overall commit sequence.

• You can order commits into a more logical sequence.
• You can remove debug code committed accidentally.

Caution About Altering History

You can alter a specific branch of your repository as long as no one has a copy of that branch. The notion to keep in mind is you shouldn’t rewrite, alter, or change any part of a branch that’s been made available and might be present in a different repository. Once you make your development history available to another developer, that chronicle is known as a “published history.” This could include reordering, combining, and removing one or more commits or, obviously, adding even more commits as new development. or changing the order of the commits. This chapter explores techniques to help you alter and improve your commit history.

Using git reset

The git reset command changes your repository and working directory to a known state. Specifically, git reset adjusts the HEAD ref to a given commit and, by default, updates the index to match that commit. If desired, git reset can also modify your working directory to mirror the revision of your project represented by the given commit. You might construe git reset as “destructive” because it can overwrite and destroy changes in your working directory. Indeed, data can be lost. Even if you have a backup of your files, you might not be able to recover your work. However, the whole point of this command is to establish and recover known states for the HEAD, index, and working directory.

The git reset command has three main options: --soft, --mixed, and --hard.

git reset --soft commit
    The --soft changes the HEAD ref to point to the given commit. The contents of your  index and working directory are left unchanged. This version of the command has the “least” effect, changing only the state of a symbolic reference so it points to a new commit.
git reset --mixed commit
    --mixed changes HEAD to point to the given commit. Your index contents are also modified to align with the tree structure named by commit, but your working directory contents are left unchanged. Note that --mixed is the default mode for git reset.
git reset --hard commit
    This variant changes the HEAD ref to point to the given commit. The contents of your index are also modified to agree with the tree structure named by the named commit. Furthermore, your working directory contents are changed to reflect the state of the tree represented by the given commit.

The git reset command also saves the original HEAD value in the ref ORIG_HEAD. This is useful, for example, if you wish to use that original HEAD’s commit log message as the basis for some follow-up commit.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ mkdir L11_reset

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ cd L11_reset/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L11_reset/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ echo "main" > main.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git add main.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git commit -m "first commit for main.txt"
[master (root-commit) 5da22ea] first commit for main.txt
 1 file changed, 1 insertion(+)
 create mode 100644 main.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ echo "resetadd" > addreset.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)   ## Accidentally added addreset.txt to index
$ git add addreset.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   addreset.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git ls-files
addreset.txt
main.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)   ## Remove addreset.txt from index
$ git reset HEAD addreset.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git ls-files
main.txt

Another common use for git reset is to simply redo or eliminate the topmost commit on a branch

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ echo "revertcommit" > revcommit.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git add revcommit.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git commit -m "revcommit.txt with first line"
[master 45f256b] revcommit.txt with first line
 1 file changed, 1 deletion(-)
 
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ echo "wrong line will be removed after commit revert" >> revcommit.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git add revcommit.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git commit -m "last line commit but will be revoked"
[master ba97f26] last line commit but will be revoked
 1 file changed, 1 insertion(+)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git show-branch --more=5
[master] last line commit but will be revoked
[master^] This commit will be revoked
[master~2] first commit for main.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ cat revcommit.txt
revertcommit
wrong line will be removed after commit revert

Suppose you now realize that the second commit is wrong and you want to go back and do it differently. This is a classic application of git reset --mixed HEAD^.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git commit -m "revcommit.txt with first line"
[master 45f256b] revcommit.txt with first line
 1 file changed, 1 deletion(-)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ echo "wrong line will be removed after commit revert" >> revcommit.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git show-branch --more=5
[master] revcommit.txt with first line
[master^] last line commit but will be revoked
[master~2] This commit will be revoked
[master~3] first commit for main.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)    ## Soft reset just the index will be updated
$ git reset --soft HEAD^

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git commit -m "revert commit of HEAD^"
[master 41655c9] revert commit of HEAD^
 1 file changed, 1 deletion(-)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ ll
total 2
-rw-r--r-- 1 ADMIN 197121  5 Dec 12 16:24 main.txt
-rw-r--r-- 1 ADMIN 197121 60 Dec 12 16:42 revcommit.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ cat revcommit.txt
revertcommit
wrong line will be removed after commit revert

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git show HEAD:revcommit.txt
revertcommit

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git reset --hard HEAD^
HEAD is now at ba97f26 last line commit but will be revoked

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git show-branch
[master] last line commit but will be revoked

Another method uses the reflog, which is a history of changes to refs within your repository.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L11_reset (master)
$ git reflog
ba97f26 (HEAD -> master) HEAD@{0}: reset: moving to HEAD^
41655c9 HEAD@{1}: commit: revert commit of HEAD^
ba97f26 (HEAD -> master) HEAD@{2}: reset: moving to HEAD^
45f256b HEAD@{3}: commit: revcommit.txt with first line
ba97f26 (HEAD -> master) HEAD@{4}: reset: moving to ORIG_HEAD
38d2ea9 HEAD@{5}: reset: moving to HEAD^
ba97f26 (HEAD -> master) HEAD@{6}: commit: last line commit but will be revoked
38d2ea9 HEAD@{7}: commit: This commit will be revoked
5da22ea HEAD@{8}: commit (initial): first commit for main.txt

Using git cherry-pick

The command git cherry-pick commit applies the changes introduced by the named commit on the current branch. It will introduce a new, distinct commit. Strictly speaking, using git cherry-pick doesn’t alter the existing history within a repository; instead, it adds to the history.

As with other Git operations that introduce changes via the process of applying a diff, you may need to resolve conflicts to fully apply the changes from the given commit. The command git cherry-pick is typically used to introduce particular commits from one branch within a repository onto a different branch. A common use is to forwardor back-port commits from a maintenance branch to a development branch.
 
During the course of normal development, a bug is fixed on the development line with commit F. If that bug turns out to be present in the 2.3 release also, the bug fix, F, can be made to the rel_2.3 branch using git cherry-pick:

$ git checkout rel_2.3
$ git cherry-pick dev~2 # commit Bug fix code, above

Another common use for cherry-pick is to rebuild a series of commits by selectively picking a batch from one branch and introducing them onto a new branch.

Suppose you had a series of commits on your development branch, my_dev, as shown in Figure 10-6, and you wanted to introduce them onto the master branch but in a substantially different order.

To apply them on the master branch in the order Y, W, X, Z, you could use the following

commands.
$ git checkout master
$ git cherry-pick my_dev^ # Y
$ git cherry-pick my_dev~3 # W
$ git cherry-pick my_dev~2 # X
$ git cherry-pick my_dev # Z

Using git revert

The git revert commit command is substantially similar to the command git cherry-pick commit with one important difference: it applies the inverse of the given commit. Thus, this command is used to introduce a new commit that reverses the effects of a given commit.

Like git cherry-pick, the revert doesn’t alter the existing history within a repository. Instead it adds a new commit to the history. A common application for git revert is to “undo” the effects of a commit that is buried, perhaps deeply, in the history of a branch. For some reason, perhaps through testing, commit D (old commit) has been deemed faulty. 

One way to fix the situation is to simply make edits to undo the effects of D and then commit the reversal directly. An easier approach is to simply run git revert:

$ git revert master~3 # commit D

If you want to change to a different branch, use git checkout. Your current branch and HEAD ref change to match the tip of the given branch.

The git reset command does not change your branch. However, if you supply the name of a branch, it will change the state of your current working directory to look like the tip of the named branch. In other words, git reset is intended to reset the current branch’s HEAD reference.

The git revert command works on full commits, not on files.

If another developer has cloned your repository or fetched some of your commits, there are implications for changing the commit history. In this case, you probably should not use commands that alter history within your repository. Instead, use git revert; do not use git reset nor the git commit --amend command described in the next section.

Changing the Top Commit

One of the easiest ways to alter the most recent commit on your current branch is with git commit --amend. Typically, amend implies that the commit has fundamentally the same content but some aspect requires adjustment or tidying. The actual commit object that is introduced into the object store will, of course, be different.

A frequent use of git commit --amend is to fix typos immediately after a commit. This is not the only use, however as with any commit, this command can amend any file or files in the repository and, indeed, can add or delete a file as part of the new commit. As with a normal git commit command, git commit --amend prompts you with an editor session in which you may also alter the commit message.

At this point, the commit is stored in Git’s object repository, albeit with small errors in the prose. To make corrections, you could simply edit the file again and make a second commit.

However, if you wish to leave a slightly cleaner commit history in your repository, then you can alter this commit directly and replace it. To do this, fix the file in your working directory. Correct the typos and add or remove files as needed. As with any commit, update the index with your changes using commands such as git add or git rm. Then issue the git commit --amend command.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ mkdir L12_commit_amend

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ cd L12_commit_amend/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L12_commit_amend/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ echo "There is typo Error in this file" > oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git add oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git commit -m "first commit"
[master (root-commit) b2390d0] first commit
 1 file changed, 1 insertion(+)
 create mode 100644 oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ echo "There is NO Error in this file" > oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git add oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git commit -m "commit iixed typo error file"
[master 121c093] commit iixed typo error file
 1 file changed, 1 insertion(+), 1 deletion(-)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git log --pretty=oneline
121c09311f7d693d385e219a1e274d1eca75b6ae (HEAD -> master) commit iixed typo error file
b2390d0020b59fba1c3c1b2566dd7aef13c0d41d first commit

Now use different method on new file

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ echo "New TYPO Error line in file" >> oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git add oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git commit -m "New error line"
[master cd42941] New error line
 1 file changed, 1 insertion(+)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git log --pretty=oneline
cd429413494aef4260750d3099a8c5213642bfdc (HEAD -> master) New error line
121c09311f7d693d385e219a1e274d1eca75b6ae commit iixed typo error file
b2390d0020b59fba1c3c1b2566dd7aef13c0d41d first commit

Edit the file content to correct text New NO Error 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ cat oldcorrect.txt
There is NO Error in this file
New NO Error line in file

Now use gir commit --amend to fix last commit without a new commit

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git add oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git commit --amend -m "fix file without new commit but with last commit itself"
[master b422963] fix file without new commit but with last commit itself
 Date: Fri Dec 12 19:51:12 2025 +0530
 1 file changed, 1 insertion(+)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git log --pretty=oneline
b422963cde77344aca3d00ae0f3b3ef7b6ebedcc (HEAD -> master) fix file without new commit but with last commit itself
121c09311f7d693d385e219a1e274d1eca75b6ae commit iixed typo error file
b2390d0020b59fba1c3c1b2566dd7aef13c0d41d first commit

Rebasing Commits



















Try full hands on with branches example

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ mkdir L07_branches

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ cd L07_branches/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L07_branches/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ echo "master" > master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git commit -m "add master.txt"
[master (root-commit) 9f3d5e2] add master.txt
 1 file changed, 1 insertion(+)
 create mode 100644 master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ ll -a
total 5
drwxr-xr-x 1 ADMIN 197121 0 Dec  8 17:43 ./
drwxr-xr-x 1 ADMIN 197121 0 Dec  8 17:41 ../
drwxr-xr-x 1 ADMIN 197121 0 Dec  8 17:45 .git/
-rw-r--r-- 1 ADMIN 197121 7 Dec  8 17:43 master.txt


ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)   ## create branch br1_master from master
$ git branch br1_master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch
! [br1_master] add master.txt
 * [master] add master.txt
--
+* [br1_master] add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)   ## create branch br2_master from master
$ git branch br2_master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch
! [br1_master] add master.txt
 ! [br2_master] add master.txt
  * [master] add master.txt
---
++* [br1_master] add master.txt

in the .gits/refs/heads folder you can see all branches

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches/.git/refs/heads (GIT_DIR!)
$ ll
total 3
-rw-r--r-- 1 ADMIN 197121 41 Dec  8 17:48 br1_master
-rw-r--r-- 1 ADMIN 197121 41 Dec  8 17:49 br2_master
-rw-r--r-- 1 ADMIN 197121 41 Dec  8 17:45 master

Try to checkout br1_master and add br1_master into master.txt 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)   ## now wokring directory is pointing to br1_master branch
$ git checkout br1_master
Switched to branch 'br1_master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ git show-branch
* [br1_master] add master.txt         ## here * specifies br1_master is the current working dir
 ! [br2_master] add master.txt
  ! [master] add master.txt
---
*++ [br1_master] add master.txt

Make two changes to the br1_master branch as shown below, create a new file and edit master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ echo "this is br1_master" > br1_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ echo "added line br1_master" >> master.txt

Try to merge br1_master now with master branch

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ git add br1_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ git commit -m "add br1 file and edit master file in br1 branch"
[br1_master e25f65b] add br1 file and edit master file in br1 branch
 1 file changed, 1 insertion(+)
 create mode 100644 br1_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ git show-branch
* [br1_master] add br1 file and edit master file in br1 branch
 ! [br2_master] add master.txt
  ! [master] add master.txt
---
*   [br1_master] add br1 file and edit master file in br1 branch
*++ [br2_master] add master.txt

now make similar changes in the br2_master branch also

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br1_master)
$ git checkout br2_master
M       master.txt
Switched to branch 'br2_master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ git show-branch
! [br1_master] add br1 file and edit master file in br1 branch
 * [br2_master] add master.txt
  ! [master] add master.txt
---
+   [br1_master] add br1 file and edit master file in br1 branch
+*+ [br2_master] add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ cat master.txt
master
added line br1_master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ echo "this is br2_master" > br2_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ git add br2_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ echo "added line br2_master" >> master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ git commit -m "add br2 file and edit master file in br2 branch"
[br2_master bb20b37] add br2 file and edit master file in br2 branch
 1 file changed, 1 insertion(+)
 create mode 100644 br2_master.txt

NOW try to merge both br1 and br2 with master branch

1) Switch to master: git checkout master
2) update master : git pull origin master (actually no changes in master, but master.txt will be overwritten now)
3) Merge the branch: git merge <branch-name>
4) Resolve conflicts if any: Edit files, then git add <files> and git commit.
5) Push changes: git push origin master

1) Switch to master: git checkout master 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ git show-branch
! [br1_master] add br1 file and edit master file in br1 branch
 * [br2_master] add br2 file and edit master file in br2 branch
  ! [master] add master.txt
---
 *  [br2_master] add br2 file and edit master file in br2 branch
+   [br1_master] add br1 file and edit master file in br1 branch
+*+ [master] add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (br2_master)
$ git checkout master
M       master.txt
Switched to branch 'master'

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch
! [br1_master] add br1 file and edit master file in br1 branch
 ! [br2_master] add br2 file and edit master file in br2 branch
  * [master] add master.txt
---
 +  [br2_master] add br2 file and edit master file in br2 branch
+   [br1_master] add br1 file and edit master file in br1 branch
++* [master] add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ cat master.txt
master
added line br1_master
added line br2_master

3) Merge the branch: git merge <branch-name>

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git merge br1_master
Updating 9f3d5e2..e25f65b
Fast-forward
 br1_master.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 br1_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ ll
total 2
-rw-r--r-- 1 ADMIN 197121 19 Dec  8 18:11 br1_master.txt
-rw-r--r-- 1 ADMIN 197121 51 Dec  8 18:04 master.txt

Now update the master.txt before next branch merge and check master.txt once merge is done

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ echo  "empty master" >  master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git merge br2_master
Merge made by the 'ort' strategy.
 br2_master.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 br2_master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ ll
total 3
-rw-r--r-- 1 ADMIN 197121 19 Dec  8 18:11 br1_master.txt
-rw-r--r-- 1 ADMIN 197121 19 Dec  8 18:15 br2_master.txt
-rw-r--r-- 1 ADMIN 197121 13 Dec  8 18:12 master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)    ## note the master.txt file is not update from the br2_master branch
$ cat master.txt
empty master

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git show-branch
! [br1_master] add br1 file and edit master file in br1 branch
 ! [br2_master] add br2 file and edit master file in br2 branch
  * [master] Merge branch 'br2_master'
---
  - [master] Merge branch 'br2_master'
 +* [br2_master] add br2 file and edit master file in br2 branch
+ * [br1_master] add br1 file and edit master file in br1 branch
++* [br2_master^] add master.txt

Try to check all commits in master now as two branches are merged already.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L07_branches (master)
$ git log -10 --pretty=oneline HEAD
0e743640e383ffdd0db25030b4dd17de20cda64c (HEAD -> master) Merge branch 'br2_master'
bb20b371a24f6951487fceb3e136e564486e4cc9 (br2_master) add br2 file and edit master file in br2 branch
e25f65b4299a5156c06befd2314cf8b0a834362a (br1_master) add br1 file and edit master file in br1 branch
9f3d5e248869500657d5218884c4a34a8cf9af1c add master.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)
$ git ls-files -s
100644 b289928088d9d4fddc9c0f24982adfe3e7c7f930 0       oldcorrect.txt

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)  ## Check the contents of file in the repo master branch
$ git cat-file -p b289928088d9d
There is NO Error in this file
New NO Error line in file

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L12_commit_amend (master)  ## File is same as the local file
$ cat oldcorrect.txt
There is NO Error in this file
New NO Error line in file

Rebasing Commits

The git rebase command is used to alter where a sequence of commits is based. This command requires at least the name of the other branch onto which your commits will be relocated. By default, the commits from the current branch that are not already on the other branch are rebased. A common use for git rebase is to keep a series of commits that you are developing up-to-date with respect to another branch, usually a master branch or a tracking branch from another repository.

If master branch has commits A B C D E and the topic branch has commits W X Y Z and the topic branch is forked from the B commit or master brach. Originally, the topic branch started on the master branch when it was at commit B. In the meantime, master has progressed to commit E. 

You can keep your commit series up-to-date with respect to the master branch by writing the commits so that they are based on commit E rather than B. Because the topic branch needs to be the current branch, you can use either:

$ git checkout topic
$ git rebase master
or
$ git rebase master topic

After the rebase operation is complete, the new commit graph will be like topic branch has commits W' X' Y' Z' and the W' commit of topic will start from the E commit in the master branch, that means all the contents of the commits from C D E in the master branch are merged into the commits W X Y Z of the topic branch. 

Using the git rebase command in situations like the one shown in Figure 10-12 is often called forward porting. In this example, the topic branch topic has been forward ported to the master branch.

The git rebase command may also be used to completely transplant a line of development from one branch to an entirely different branch using the --onto option. The rebase operation relocates commits one at a time from each respective original commit location to a new commit base. As a result, each commit that is moved might have conflicts to resolve. If a conflict is found, the rebase operation suspends its processing temporarily so you can resolve the conflict. Any conflict during the rebase process that needs to be resolved should be handled as you handle the merge conflict. 

Once all conflicts are resolved and the index has been updated with the results, the rebase operation can be resumed using the git rebase --continue command. the command resumes its operation by committing the resolved conflict and proceeding to the next commit in the series being rebased.

If, while inspecting a rebase conflict, you decide that this particular commit really isn’t necessary, then you can also instruct the git rebase command to simply skip this commit and move to the next by using git rebase --skip. This may not be the correct thing to do, especially if subsequent commits in the series really depend on the changes introduced by this one. The problems are likely to snowball in this case, so it’s better to truly resolve the conflict.

Finally, if the rebase operation turns out to be the totally wrong thing to do, git rebase --abort abandons the operation and restores the repository to the state prior to issuing the original git rebase.

Using git rebase -i

Suppose you start writing a haiku and manage to compose two full lines before checking it in:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ mkdir L13_rebase

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git
$ cd L13_rebase/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase
$ git init
Initialized empty Git repository in H:/git_repo/learn_git/L13_rebase/.git/

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ cat > haiku
Talk about colour
No jealous behaviour here
^d

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ cat haiku
Talk about colour
No jealous behaviour here

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git add haiku

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git commit -m "Start my Haiku"
[master (root-commit) af715c9] Start my Haiku
 1 file changed, 2 insertions(+)
 create mode 100644 haiku

but you decide you really should use the American spelling of color instead of the British. So, you make a commit to change it:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ vi haiku

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ cat haiku
Talk about color          ## u removed from colour
No jealous behaviour here

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git diff
diff --git a/haiku b/haiku
index 088bea0..958aff0 100644
--- a/haiku
+++ b/haiku
@@ -1,2 +1,2 @@
-Talk about colour
+Talk about color
 No jealous behaviour here

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git add haiku

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git commit -m "Use color instead of colour"
[master 9bdf69d] Use color instead of colour
 1 file changed, 1 insertion(+), 1 deletion(-)

Finally, you develop the final line and commit it:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ cat >> haiku
I favour red wine
^d

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git add haiku

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git commit -m "Finish my colour haiku"
[master aa6953a] Finish my colour haiku
 1 file changed, 1 insertion(+)

However, again you have spelling quandary and decide to change all British “ou” spellings to the American “o” spelling:

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ vi haiku

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ cat haiku
Talk about color
No jealous behavior here     ## u removed
I favor red wine             ## u removed

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git add haiku

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git commit -a -m "Use American spellings"
[master 0622d2f] Use American spellings
 1 file changed, 2 insertions(+), 2 deletions(-)

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)   ## accumulated a history of commits
$ git show-branch --more=6
[master] Use American spellings
[master^] Finish my colour haiku
[master~2] Use color instead of colour
[master~3] Start my Haiku

But then you also notice that there’s no good reason to have two similar commits that correct the spellings of different words. Thus, you would also like to squash the mas ter and master^ into just one commit.

Reordering, editing, removing, squashing multiple commits into one, and splitting a commit into several are all easily performed by the git rebase command using the -i or --interactive option. This command allows you to modify the commits that make up a branch and place them back onto the same branch or onto a different branch.

A typical use, and one apropos for this example, modifies the same branch in place. In this case there are three changesets between four commits to be modified; git rebase -i needs to be told the name of the commit beyond which you actually intend to change.


ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git rebase -i master~3
Successfully rebased and updated refs/heads/master.      ## After the editor is closed

You will be placed in an editor on a file that looks like this:

pick 9bdf69d Use color instead of colour
pick aa6953a Finish my colour haiku
pick 0622d2f Use American spellings

# Rebase af715c9..0622d2f onto af715c9 (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
....
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#


The first three lines list the commits within the editable commit range you specified on the command line. The commits are initially listed in order from oldest to most recent and have the pick verb on each one. If you were to leave the editor now, each commit would be picked (in order), applied to the target branch, and committed.

At this point, however, you are free to reorder the commits, squash commits together, change a commit, or delete one entirely. To follow the listed steps, simply reorder the commits in your editor as follows and exit it:

pick aa6953a Finish my colour haiku
pick 9bdf69d Use color instead of colour
pick 0622d2f Use American spellings

Recall that the very first commit for the rebase is the “Start my haiku” commit. The next commit will become “Finish my colour haiku,” followed by the “Use color ...” and “Use American ...” commits.

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)    ## now the commit order is changed
$ git show-branch --more=6
[master] Use American spellings
[master^] Use color instead of colour
[master~2] Finish my colour haiku
[master~3] Start my Haiku

Here, the history of commits has been rewritten; the two spelling commits are together and the two writing commits are together. Still following the outlined order, your next step is to squash the two spelling commits into just one commit. Again, issue the git rebase -i master~3 command. This time, convert the commit list as 

pick d83f7ed Finish my colour haiku
pick 1f7342b Use color instead of colour
squash 1915dae Use American spellings

# This is a combination of 2 commits.
# This is the 1st commit message:
Use American spellings - combined        ## New commit comment in editor
Use color instead of colour 

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/git_repo/learn_git/L13_rebase (master)
$ git show-branch --more=6
[master] Use American spellings - combined Use color instead of colour
[master^] Finish my colour haiku
[master~2] Start my Haiku

• Rebase rewrites commits as new commits.
• Old commits that are no longer reachable are gone.
• Any user of one of the old, pre-rebase commits might be stranded.
• If you have a branch that uses a pre-rebase commit, you might need to rebase it in turn.
• If there is a user of a pre-rebase commit in a different repository, he still has a copy of that commit even though it has moved in your repository; the user will now have to fix up his commit history, too.

By default, root users have # prompt, regular users have $ in Linux.

root user:    root@hostname:~#  ← # symbol
regular user: user@hostname:~$  ← $ symbol

#### Setup local GIT project and sync it with Git hub repository. Keep changing the code and push them to github repo.

Move into the .ssh folder
(mypyvenv) root@ubundockhost:~/# cd ~/.ssh

## Install Git (if not installed)
(mypyvenv) root@ubundockhost:~/.ssh# sudo apt install -y git
Reading package lists... Done

## Configure Git Global Identity
(mypyvenv) root@ubundockhost:~/.ssh# git config --global user.name "Sivanesan G"
(mypyvenv) root@ubundockhost:~/.ssh# git config --global user.email "nesan.committer@gmail.com"

(mypyvenv) root@ubundockhost:~/.ssh# export GIT_AUTHOR_NAME="Sivanesan G"
(mypyvenv) root@ubundockhost:~/.ssh# export GIT_AUTHOR_EMAIL="nesan.committer@gmail.com"

## Set Up Authentication - Use ssh key method with github website for your mail ID registered with github website

# Generate SSH Key Pair - Uses ed25519 keygen algorithm which is better than RSA, Elliptic Curve math creates mathematically linked key pair.

(mypyvenv) root@ubundockhost:~/.ssh# ssh-keygen -t ed25519 -C "nesan.committer@gmail.com"
Generating public/private ed25519 key pair.
Enter file in which to save the key (/root/.ssh/id_ed25519): githubweb
Enter passphrase (empty for no passphrase): passxxx
Enter same passphrase again: passxxx
Your identification has been saved in githubweb
Your public key has been saved in githubweb.pub
The key fingerprint is:
SHA256:Qlkp7+GgwVRsX4YY1G7nSzEG0q9Pz/FpgIed85f2+kc nesan.committer@gmail.com
The key's randomart image is:
+--[ED25519 256]--+
|     ++=.o       |
|    . *o* o      |
|   o .o* =       |
|    o.. * *      |
|     o.=S* * .   |
|    .  .+ * B   E|
|         + = * o.|
|          o o =oo|
|             .o+=|
+----[SHA256]-----+
(mypyvenv) root@ubundockhost:~/.ssh#

#check the files in the path /root/.ssh/
(mypyvenv) root@ubundockhost:~/.ssh# ll
total 28
drwx------ 1 root root 4096 Dec 27 19:41 ./
drwx------ 1 root root 4096 Dec 27 19:12 ../
-rw------- 1 root root  464 Dec 27 19:35 githubweb
-rw-r--r-- 1 root root  107 Dec 27 19:35 githubweb.pub
-rw------- 1 root root 2240 Dec 21 23:33 known_hosts
-rw------- 1 root root 1120 Dec 19 12:24 known_hosts.old
(mypyvenv) root@ubundockhost:~/.ssh#

key generation is successful private key and public key are generated for the githubweb with files githubweb and githubweb.pub respectively

/githubweb          ← PRIVATE KEY (SECRET - never share!)
/githubweb.pub      ← PUBLIC KEY  (safe to copy to GitHub)

#Copy Public Key

(mypyvenv) root@ubundockhost:~/.ssh# cat githubweb.pub
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILQs4f9ZPhCAEoE3COGDT3IKxfDfaleiJnOFpcZWWnL5 nesan.committer@gmail.com

#Add the public key to GitHub website
GitHub.com → Settings → SSH and GPG keys → New SSH key
Title: "Key from DE genie Docker"
Key: [paste cat output]
Add SSH key

# Run the SSH agent in the docker 
(mypyvenv) root@ubundockhost:~/.ssh# eval "$(ssh-agent -s)"
Agent pid 1841

## Add private key to ssh agent in the docker - SSH Agent Loads Private Key
(mypyvenv) root@ubundockhost:~/.ssh# ssh-add githubweb
Enter passphrase for githubweb: passxxx
Identity added: githubweb (nesan.committer@gmail.com)
(mypyvenv) root@ubundockhost:~/.ssh#

## Test Connection with github.com -- ssh -T <user@hostname_or_IP>
(mypyvenv) root@ubundockhost:~/.ssh# ssh -T git@github.com 
The authenticity of host 'github.com (20.207.73.82)' can't be established.
ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'github.com' (ED25519) to the list of known hosts.
Hi nesancommitter! You've successfully authenticated, but GitHub does not provide shell access.

## Test connection again   -- ssh -T <user@hostname_or_IP>
(mypyvenv) root@ubundockhost:~/.ssh# ssh -T git@github.com
Hi nesancommitter! You've successfully authenticated, but GitHub does not provide shell access.

##GitHub Workflow Now Ready
##Now push the first set of files to Github

# Enter the folder which you want to push to Github 
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# cd /mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# ll
total 752
drwxr-xr-x 1 root root    512 Dec 27 20:16 ./
drwxrwxrwx 1 root root    512 Dec 27 20:16 ../
-rwxrwxrwx 1 root root  22893 Dec 20 16:54 AWS_CLI_command_bible.xlsx*
-rwxrwxrwx 1 root root  91683 Dec 26 03:54 AWS_CLI_learn.txt*
-rwxrwxrwx 1 root root  99750 Dec 27 13:40 AWS_Learn.txt*
-rwxrwxrwx 1 root root 187958 Dec 27 20:14 AWS_instancetypes_ap-south-1.xlsx*
drwxr-xr-x 1 root root    512 Dec 17 02:54 All_Data_for_learning/
-rwxrwxrwx 1 root root  85769 Dec 26 03:53 DE_Docker_setup_full.txt*
-rwxrwxrwx 1 root root  23779 Dec 16 12:03 Docker_Basics.txt*
-rwxrwxrwx 1 root root  10154 Dec 27 20:15 Input_data_DE_handson_SQL_handson.xlsx*
drwxrwxrwx 1 root root    512 Dec 27 16:24 Ref_Books/
-rwxrwxrwx 1 root root 235439 Dec 16 12:04 Versioning_with_GIT.txt*
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share#

# Make that git project repository with git inti command 

(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git init
hint: Using 'master' as the name for the initial branch. This default branch name
hint: is subject to change. To configure the initial branch name to use in all
hint: of your new repositories, which will suppress this warning, call:
hint:
hint:   git config --global init.defaultBranch <name>
hint:
hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and
hint: 'development'. The just-created branch can be renamed via this command:
hint:
hint:   git branch -m <name>
Initialized empty Git repository in /mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share/.git/
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share#

# Stages ALL changes in current directory -- Current folder + all subfolders 
# Moves files from working directory → staging area (index)
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git add .

## Add certain files in the .gitignore file so those files are always ignored from commit/push into the repository
# Create/edit .gitignore 
ADMIN@DESKTOP-O8I6CUH MINGW64 /h/All_Notes_from_learning/All_Notes_to_Share (main)
$ echo "~*" >> .gitignore

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/All_Notes_from_learning/All_Notes_to_Share (main)
$ echo "*~" >> .gitignore

ADMIN@DESKTOP-O8I6CUH MINGW64 /h/All_Notes_from_learning/All_Notes_to_Share (main)
$ echo "~$*" >> .gitignore



# Commits the current stanged/indexed files in the local repository .git/objects/
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git commit -m "Initial commit dt_2025_12_27"
[master (root-commit) 71b3ab8] Initial commit dt_2025_12_27
 15 files changed, 133118 insertions(+)
 create mode 100755 AWS_CLI_command_bible.xlsx
 create mode 100755 AWS_CLI_learn.txt
 create mode 100755 AWS_Learn.txt
 create mode 100755 AWS_instancetypes_ap-south-1.xlsx

# Create repository in the github portal
GitHub.com →  Sign in as nesancommitter → Click "New" (green button) → Repository name: All_Notes_to_Share
Title: "repo for all notes created from learning"

Once created Copy SSH URL: 
git@github.com:nesancommitter/All_Notes_to_Share.git


# Add remote -- Links your local repo → GitHub repo nesancommitter/All_Notes_to_Share
## Set the SSH URL to the remote repo associate it to the remote repo name All_Notes_to_Share configured locally
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git remote add All_Notes_to_Share git@github.com:nesancommitter/All_Notes_to_Share.git

Creates entry in .git/config file
Links your local repo → GitHub repo nesancommitter/All_Notes_to_Share
SSH protocol = passwordless (your githubweb key)

# Check the entries in the .git/config file
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# cat .git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
        ignorecase = true
[remote "All_Notes_to_Share"]
        url = git@github.com:nesancommitter/All_Notes_to_Share.git
        fetch = +refs/heads/*:refs/remotes/All_Notes_to_Share/*

# Verify there is entry to the remote repo
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git remote -v
All_Notes_to_Share      git@github.com:nesancommitter/All_Notes_to_Share.git (fetch)
All_Notes_to_Share      git@github.com:nesancommitter/All_Notes_to_Share.git (push)
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share#

# Set Git's default branch globally for this user as main With Git configuration manager Apply to ALL repositories for this user Controls git init default branch name and set it to main as New default branch name
# Verify GitHub's branch is set to main
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git config --global init.defaultBranch main
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git config --global init.defaultBranch 
main
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share#

## check what happened to the current repository - branch is set to main which is in sync with Github portal
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git branch   
* main

## Git push the local branch (main) to the remote github repository
# -u  -- sets upstream tracking (future git push works without branch name - tracks All_Notes_to_Share/main remote/local_branch forever)  
# git push -u <Remote_nickname> <remote_branch_to_use>
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git push -u All_Notes_to_Share main
Enumerating objects: 41, done.
Counting objects: 100% (41/41), done.
Delta compression using up to 6 threads
Compressing objects: 100% (35/35), done.
Writing objects: 100% (41/41), 27.61 MiB | 4.44 MiB/s, done.
Total 41 (delta 10), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (10/10), done.
To github.com:nesancommitter/All_Notes_to_Share.git
 * [new branch]      main -> main
branch 'main' set up to track 'All_Notes_to_Share/main'.

Behind the scenes (Network Flow):
Your Docker → SSH (githubweb key) → GitHub Servers → nesancommitter/All_Notes_to_Share
     ↓
Creates: master branch + all your files

## Check all the files are uploaded 
visit https://github.com/nesancommitter/All_Notes_to_Share/

## Your Daily Workflow to update the changes from local into Git repo in github
## Make any changes to any files in the folder -- add all the files to index, commit the index, the push it to remote repo in this case github
git add .
git commit -m "Add new notes"
git push                            # Just 'push' - tracks master automatically

## to test if the changes are working any anyone can clone the repository
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning# cd /mnt/hdrive/scrap/
(mypyvenv) root@ubundockhost:/mnt/hdrive/scrap# mkdir gitrep_test
(mypyvenv) root@ubundockhost:/mnt/hdrive/scrap# cd gitrep_test/
(mypyvenv) root@ubundockhost:/mnt/hdrive/scrap/gitrep_test# git init
(mypyvenv) root@ubundockhost:/mnt/hdrive/scrap/gitrep_test# git clone --recursive https://github.com/nesancommitter/All_Notes_to_Share.git
Cloning into 'All_Notes_to_Share'...
remote: Enumerating objects: 26, done.
remote: Counting objects: 100% (26/26), done.
remote: Compressing objects: 100% (20/20), done.
remote: Total 26 (delta 0), reused 23 (delta 0), pack-reused 0 (from 0)
Receiving objects: 100% (26/26), 26.30 MiB | 9.33 MiB/s, done.

## Check all files are cloned properly
(mypyvenv) root@ubundockhost:/mnt/hdrive/scrap/gitrep_test/All_Notes_to_Share# ll
total 752
drwxr-xr-x 1 root root    512 Dec 28 00:11 ./
drwxr-xr-x 1 root root    512 Dec 28 00:11 ../
drwxr-xr-x 1 root root    512 Dec 28 00:11 .git/
-rwxr-xr-x 1 root root  22893 Dec 28 00:11 AWS_CLI_command_bible.xlsx*
-rwxr-xr-x 1 root root  91479 Dec 28 00:11 AWS_CLI_learn.txt*
-rwxr-xr-x 1 root root  99750 Dec 28 00:11 AWS_Learn.txt*
-rwxr-xr-x 1 root root 187958 Dec 28 00:11 AWS_instancetypes_ap-south-1.xlsx*
drwxr-xr-x 1 root root    512 Dec 28 00:11 All_Data_for_learning/
-rwxr-xr-x 1 root root  85769 Dec 28 00:11 DE_Docker_setup_full.txt*
-rwxr-xr-x 1 root root  23779 Dec 28 00:11 Docker_Basics.txt*
-rwxr-xr-x 1 root root  10154 Dec 28 00:11 Input_data_DE_handson_SQL_handson.xlsx*
drwxr-xr-x 1 root root    512 Dec 28 00:11 Ref_Books/
-rwxr-xr-x 1 root root 235439 Dec 28 00:11 Versioning_with_GIT.txt*

## Touch to add new learn file and commit and push the repo to git hub
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# touch AWS_Glue_Learn.txt
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git add .
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git commit -m "start glue"
[master 8919456] start glue
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 AWS_Glue_Learn.txt
 
## Now push the new changes - new file to github
## can just use git push or git push All_Notes_to_Share master both are same
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# git push

Enumerating objects: 4, done.
Counting objects: 100% (4/4), done.
Delta compression using up to 6 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 282 bytes | 31.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To github.com:nesancommitter/All_Notes_to_Share.git
   23cac7c..8919456  master -> master

## Check in the github repo you can find the new file named AWS_Glue_Learn.txt in below repo

https://github.com/nesancommitter/All_Notes_to_Share

## Check contents of the .git/config file once to understand
(mypyvenv) root@ubundockhost:/mnt/hdrive/All_Notes_from_learning/All_Notes_to_Share# cat .git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
        ignorecase = true
[remote "All_Notes_to_Share"]
        url = git@github.com:nesancommitter/All_Notes_to_Share.git
        fetch = +refs/heads/*:refs/remotes/All_Notes_to_Share/*
[branch "main"]
        remote = All_Notes_to_Share
        merge = refs/heads/main

## Git command to just reverse the last commit 
## Remove last commit but KEEP the changes (as untracked/unstaged)
## This uncommits and keeps the changes in your working directory, not staged: so you can stage it and recommit differently.
git reset --mixed HEAD~1   # or simply: git reset HEAD~1

#Make required changes in issue file save the changes and trigger git add again
git add . 

#Then you can git commit again to commit the new changes 
git commit -m "revert last commit and commit again"



































git clone --recursive https://github.com/torvalds/linux.git



The default branch has been renamed!

master is now named main
If you have a local clone, you can update it by running the following commands.

git branch -m master main
git fetch origin
git branch -u origin/main main
git remote set-head origin -a































































